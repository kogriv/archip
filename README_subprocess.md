## Описание
Модуль `subprocess` в Python предоставляет удобные функции для запуска внешних процессов, взаимодействия с ними и получения результатов выполнения. Этот модуль является более удобной и мощной альтернативой устаревшему модулю os.system.

В контексте модуля `subprocess` в Python, термин **"процесс"** относится к отдельному выполняемому экземпляру программы. Когда вы используете `subprocess` для выполнения внешней команды, **создается отдельный процесс** операционной системы для выполнения этой команды.

Процесс включает в себя **исполняемый код, данные и ресурсы**, необходимые для его выполнения. Каждый процесс имеет свое собственное **адресное пространство, переменные окружения и другие атрибуты**, которые изолируют его от других процессов.

Модуль `subprocess` предоставляет средства для создания, управления и взаимодействия с процессами. Вы можете запускать **внешние команды, передавать им аргументы, управлять вводом/выводом и получать результаты выполнения**.

Пример создания процесса с использованием subprocess:
```python
import subprocess

result = subprocess.run(["echo", "Hello, subprocess!"], capture_output=True, text=True)
print(result.returncode)
print(result.stdout)
```
В этом примере создается процесс для выполнения команды `"echo"`, и результат выполнения этого процесса сохраняется в объекте `result`.

## subprocess.run
`subprocess.run`: Это простой способ запуска процесса и ожидания его завершения. Он возвращает объект класса `CompletedProcess` с информацией о выполненном процессе, такой как код возврата.
```python
import subprocess

result = subprocess.run(["echo", "Hello, subprocess!"], capture_output=True, text=True)
print(result.returncode)
print(result.stdout)
```

## Список аргументов методов .run .Popen
В модуле `subprocess` функции, такие как `run` или `Popen`, ожидают, что первым аргументом будет передан список строк, где  
- первый элемент списка - это исполняемая команда,
- остальные элементы - это аргументы этой команды.

В примере `["echo", "Hello, subprocess!"]`, `"echo"` - это команда, которую вы хотите выполнить, а `"Hello, subprocess!"` - это аргумент, передаваемый этой команде. Когда эта команда выполняется, она выводит строку "Hello, subprocess!".

## Аттрибут shell=True метода .run
Выполнение инструкции `subprocess.run(["echo", "Hello, subprocess!"], capture_output=True, text=True)` в теримнале `PowerShell` в Windows приведет к ошибке: `FileNotFoundError: [WinError 2] Не удается найти указанный файл`.  
Это означает, что система не может найти указанный исполняемый файл `"echo"`, который не является исполняемым файлом в системе Windows. Команда `"echo"` - это встроенная команда оболочки в командной строке Windows, и она не представляет собой отдельный исполняемый файл.  

При этом инструкция `subprocess.run(["echo", "Hello, subprocess!"], capture_output=True, text=True)` записана с использованием списка аргументов `["echo", "Hello, subprocess!"]`.

Если вы хотите запустить команду `"echo"` через `subprocess.run`, вы можете использовать `shell=True`, чтобы интерпретатор командной строки Windows обработал эту команду:
```python
import subprocess

result = subprocess.run("echo Hello, subprocess!", capture_output=True, text=True, shell=True)
print(result.returncode)
print(result.stdout)
```

Аргумент `shell` в функции `subprocess.run` определяет, будет ли команда выполняться в оболочке операционной системы. Если `shell=True`, то команда запускается через командную оболочку (например, `/bin/sh` в Unix или `cmd.exe` в Windows), что позволяет использовать различные возможности оболочки, такие как метасимволы, перенаправление потоков и т. д.

Установка `shell=True` порождает вспомогательный процесс оболочки, в котором затем выполняется команда.

## Опасность использования shell=True
Использование `shell=True` может быть потенциально опасным, так как это может предоставить доступ к выполнению произвольных команд через командную строку.

При использовании передачи списка аргументов и отсутствии `shell=True`, скрипт контролирует, какие конкретные команды будут выполняться, и предотвращает интерпретацию аргументов как части командной оболочки.

Рассмотрим потенциально опасный вариант использования `shell=True` и выполнения переданной команды "как есть" (т.е. в виде строки).  
**Внимание!!! код ниже запускать не рекомендуется!!!**
```python
user_input = "Hello; rm -rf /"  # Плохая практика, не делайте так!
command = f"echo {user_input}"
result = subprocess.run(command, shell=True, capture_output=True, text=True)
```
В данном случае, запуск `.run` приводит (с включенным аргументом `shell=True`) к выполнению команды, описанной в инструкции `user_input = "Hello; rm -rf /`- **как есть** - при этом введенное значение `user_input` содержит команду с разделителем `;` - т.е. произойдет выполнение двух отдельных команд:

- `echo Hello`
- `rm -rf /`

Это представляет **серьезную угрозу** для системы, поскольку команда `rm -rf /` представляет собой команду **удаления файлов и директорий**, начиная с корневой директории `/`. В результате выполнения этой команды весь **файловый система может быть повреждена или даже удалена**, что может привести к потере данных и некорректной работе системы.

Данный пример является чрезвычайно плохой практикой и используется здесь исключительно для демонстрации потенциальной угрозы при использовании `shell=True` с внешним вводом. В реальном коде следует избегать использования `shell=True` при работе с внешними данными и всегда использовать передачу списка аргументов для предотвращения возможных атак на основе инъекций команд.

Если бы вы использовали передачу списка аргументов, эта проблема была бы исключена. Потому что при выполнении команды через `subprocess.run` с использованием списка аргументов, каждый элемент списка считается отдельным аргументом для выполняемой команды, и команды не интерпретируются как часть оболочки.

```python
user_input = "Hello; rm -rf /"
command = ["echo", user_input]
result = subprocess.run(command, capture_output=True, text=True)
```

Здесь `subprocess.run` обрабатывает `command` как список аргументов, а не как строку, подлежащую интерпретации оболочкой. Таким образом, значение `user_input`, содержащее разделитель `;`, будет рассматриваться как один аргумент, а не как разделитель команд.

В результате, при выполнении этого кода, команда `echo` будет отображать всю строку `"Hello; rm -rf /"`, а не пытаться выполнить несколько команд.

Т.е. при выключенном `shell` и передаче списка аргументов в скрипте явно определяется команда (`echo`) которая (и только она) будет выполнятся функцией `subprocess.run`

## Описание subprocess.Popen
Этот метод позволяет более тонко управлять процессом и его вводом/выводом. Вы можете использовать Popen для запуска процесса и даже взаимодействия с ним в реальном времени.
```python
import subprocess

process = subprocess.Popen(["ls", "-l"], stdout=subprocess.PIPE, text=True)
output, error = process.communicate()

print(output)
```

## Потоки ввода/вывода
Можно перенаправлять стандартные потоки ввода, вывода и ошибок процесса. Например:

```python
import subprocess

with open("output.txt", "w") as f:
    subprocess.run(["ls", "-l"], stdout=f)
```

## Обработка исключений
Модуль также предоставляет subprocess.CalledProcessError, который может быть использован для обработки ошибок выполнения процесса.

```python
mport subprocess

try:
    subprocess.run(["command_not_found"], check=True)
except subprocess.CalledProcessError as e:
    print(f"Error: {e}")
```

## Сравнение .run() и .check_output()
Есть такой код:
```python
# Выполняем команду "conda env list --json" и декодируем вывод
envs_info = subprocess.check_output(\
    ["conda", "env", "list", "--json"]).decode("utf-8")
```
он может быть записан с использованием `.run()`
```python
result = subprocess.run(["conda", "env", "list", "--json"], capture_output=True, text=True)
envs_info = result.stdout
```

Различия между методами run и check_output в модуле subprocess в Python:  
**subprocess.run**:
- `subprocess.run` выполняет команду и возвращает объект `CompletedProcess`.
- В отличие от `check_output`, он не возвращает вывод команды напрямую.
- Вывод команды можно получить из атрибута stdout объекта `CompletedProcess`.

**subprocess.check_output**:
- `subprocess.check_output` выполняет команду и возвращает ее вывод в виде байтов.
- В данном случае, мы используем decode(`"utf-8"`), чтобы преобразовать байты в строку.
- Если команда завершится неудачно, будет вызвано исключение `CalledProcessError`.

Выбор между `run` и `check_output` зависит от того, нужно ли вам также обрабатывать другие аспекты выполнения команды, такие как **код возврата**, **вывод ошибок** и так далее. Если вам нужно **более тонкое управление и анализ выполнения команды, run** может быть более удобным. Если вам нужен **только вывод команды, check_output** может быть более простым в использовании.