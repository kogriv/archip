## Динамческая типизация
Термин "динамическая типизация" относится к особенности языка программирования, при которой типы данных определяются и проверяются во время выполнения программы, а не во время компиляции. Динамическая типизация предоставляет гибкость в работе с типами данных, позволяя переменным принимать значения различных типов на протяжении выполнения программы.

При динамической типизации в Python переменные не обязаны быть связаны с определенным типом данных на протяжении всей программы. Вместо этого, типы данных определяются на основе присваиваемых значений.

```python
x = 5  # x становится целым числом (int)
print(x)  # Вывод: 5

x = "Hello"  # x теперь становится строкой (str)
print(x)  # Вывод: Hello

x = [1, 2, 3]  # x теперь становится списком (list)
print(x)  # Вывод: [1, 2, 3]
```

Здесь переменная x сначала ассоциируется с типом данных int, затем с типом str, и наконец с типом list. Это возможно благодаря динамической типизации, которая позволяет переменным изменять свой тип во время выполнения программы.

## Интерфейс объектов. Описание isinstance.
Самое главное - в Python гораздо важнее ***интерфейс объекта***, чем его точный класс. Интерфейс - это реализация различных методов, включая дандеры `__method__`.
`isinstance()` в Python используется для проверки типа объекта. Эта функция принимает два аргумента: объект и тип. Она возвращает True, если объект является экземпляром указанного типа, и False в противном случае.
`isinstance()` фактически "смотрит" на **интерфейс** объекта и проверяет, есть ли у него методы, которые свойственны классу.

Реализация `isinstance()` основана на механизме наследования и сравнении типов объектов. Внутри Python реализован механизм, который проверяет, является ли объект экземпляром указанного класса или его подкласса.

Для пользовательского класса в Python, чтобы его экземпляры корректно возвращали True при вызове `isinstance()`, класс должен предоставить метод `__instancecheck__()`. Этот метод вызывается внутри `isinstance()` для определения, является ли объект экземпляром данного класса. Это позволяет классам определять свое собственное поведение для проверки типов.

Примерно так выглядит интерфейс пользовательского класса, чтобы поддерживать isinstance():
```python
class MyClass:
    def __init__(self, value):
        self.value = value

    def __instancecheck__(self, instance):
        # Проверяем, является ли instance экземпляром MyClass или его подкласса
        return isinstance(instance, MyClass)
```

## Кастомный `__instancecheck__`
Метод `__instancecheck__()` может содержать любую логику, не ограниченную только проверкой типа. Этот метод предоставляет пользовательскому классу возможность определить специфическое поведение для проверки экземпляров.

Например, пользовательский класс может реализовать сложную логику проверки, основанную не только на типе объекта, но и на его состоянии, атрибутах или даже внешних условиях.

Вот пример, демонстрирующий более сложную логику в методе `__instancecheck__()`:
```python
class MyClass:
    def __init__(self, value):
        self.value = value

    def __instancecheck__(self, instance):
        # Проверяем, является ли instance экземпляром MyClass или его подкласса
        # и имеет значение value больше нуля
        return isinstance(instance, MyClass) and instance.value > 0

# Пример использования
obj1 = MyClass(5)
obj2 = MyClass(-1)

print(isinstance(obj1, MyClass))  # Вывод: True
print(isinstance(obj2, MyClass))  # Вывод: False, потому что obj2.value <= 0
```

Можно например реализовать подобным образом класс какой то породы собак. Каждый экземпляр класса каким то (рандомным) образом получает свойство, напрмер, перекраса: процент площади темных пятен. При прекрасе, напрмер, более 40% экземпляр уже не будет считаться объектом класса данной полроды.

## Утиная типизация.
В Python **"утиная типизация"** или "динамическая типизация" обеспечивает гибкость в работе с объектами, основанную на их поведении, а не строго определенном типе.  
Основной принцип "утиной типизации" заключается в том, что тип объекта в Python определяется его поведением (то есть наличием определенных методов и атрибутов), а не жестким указанием его класса или типа. Это означает, что если объект выглядит как утка, плавает как утка и крякает как утка, то его можно считать уткой.

Когда вы вызываете `isinstance()`, интерпретатор Python проверяет, соответствует ли переданный объект указанному типу. Внутренне это может включать в себя ***проверку наличия необходимых атрибутов и методов***, которые определены для этого типа. Если объект обладает соответствующими атрибутами и методами, то `isinstance()` возвращает True.  
в Python функция `isinstance()` не строит свою проверку исключительно на основе иерархии наследования или наличия определенного метода `__instancecheck__()` в классе.  

При проверке принадлежности типу `isinstance()` (при нереализованном `__instancecheck__`) "смотрит" дандерметоды.

## "duck typing" Пример кастомного итератора
Если мы создадим итератор `inst_of_my_iter` не наследуя его от `Iterable` явно, и не реализовав в нем `__instancecheck__()`, то потом при проверке `instance(inst_of_my_iter, Iterable )` мы получим все-равно `True`.  
Это происходит из-за того, что в Python проверка `isinstance()` не ограничивается только явным наследованием или реализацией интерфейса через `__instancecheck__()`. Вместо этого, Python использует механизм **"duck typing"**, который оценивает объекты и их методы на основе их поведения.

Итераторы в Python обычно реализуют два метода: `__iter__()` и `__next__()`. Хотя итератор `inst_of_my_iter` может не быть явно классифицирован как `Iterable`, если он имеет методы, соответствующие интерфейсу итератора, то `isinstance(inst_of_my_iter, Iterable)` вернет `True`.  
Когда вы вызываете `isinstance(inst_of_my_iter, Iterable)`, интерпретатор Python фактически проверяет, имеет ли объект `inst_of_my_iter` необходимые методы, которые делают его "итерируемым".  
Интерфейс итератора в Python обычно включает в себя наличие метода `__iter__()`, который возвращает сам итератор, и метода `__next__()`, который возвращает следующий элемент и поднимает исключение `StopIteration` в конце последовательности.

Таким образом, isinstance() фактически "смотрит" на интерфейс объекта и проверяет, есть ли у него методы, которые свойственны классу `Iterable`. Если объект имеет подходящий интерфейс, то `isinstance()` возвращает True.

## "duck typing" Пример My INT
Если вы создадите класс `MyLikeInt`, который имеет **интерфейс, сходный с int**, но не является его подклассом и не реализует метод `__instancecheck__()`, то при проверке экземпляра такого класса с помощью `isinstance()`, `isinstance(inst_my_like_int, int)` вернет `True`. Это связано с гибкостью "утиной типизации" в Python.

Предположим, что ваш класс `MyLikeInt` обладает методами, которые обычно присущи типу `int`, такими как арифметические операции и преобразования типов. В этом случае, если объект `inst_my_like_int` предоставляет аналогичные методы, то Python считает его схожим с типом `int` и возвращает `True`, когда вы вызываете `isinstance(inst_my_like_int, int)`.

То же самое касается проверки `isinstance(inst_my_like_int, MyLikeInt)`. Если `inst_my_like_int` обладает теми же методами и поведением, что и ожидается от объекта типа `MyLikeInt`, то результатом такой проверки будет `True`, основываясь на принципах "утиной типизации".

## issubclass()
Для проверки типа класса можно использовать функцию `issubclass()`, которая определяет, является ли один класс подклассом другого.

Пример использования issubclass():
```python
class ParentClass:
    pass

class ChildClass(ParentClass):
    pass

print(issubclass(ChildClass, ParentClass))  # Вывод: True, так как ChildClass является подклассом ParentClass
```

Для проверки, является ли один класс подклассом другого, используется метод класса `__subclasscheck__()`
```python
class ParentClass:
    def __subclasscheck__(cls, subclass):
        return issubclass(subclass, ParentClass)

class ChildClass(ParentClass):
    pass

class AnotherClass:
    pass

print(issubclass(ChildClass, ParentClass))  # Вывод: True
print(issubclass(AnotherClass, ParentClass))  # Вывод: False
```

