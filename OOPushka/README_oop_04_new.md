## Описание метода __new__
Магический метод __new__ вызывается перед созданием объекта.
Выполним
```python
class Point():
    def __new__(cls, *args, **kwargs):
        print('Вызов __new__ для'+str(cls))

    def __init__(self, x=0, y=0):
        print('Вызов метода __init__'+str(self))
        self.x = x
        self.y = y

pt = Point(1,2)
print(pt)
```
`cls` - ссылка на текущий экземпляр класса - как объект базового класса Object
`self` - ссылка еа уже созданный экземпляр
>>>
```cmd
Вызов __new__ для<class '__main__.Point'>
None
```
Т.е. метод __init__ не был вызван. Объект `pt` не был создан. Поскольку при использовании метода __new__ не был возвращен адрес нового объекта. Добавим:
```python
class Point():
    def __new__(cls, *args, **kwargs):
        print('Вызов __new__ для'+str(cls))
        return super().__new__(cls)
```
>>>
```cmd
Вызов __new__ для<class '__main__.Point'>
Вызов метода __init__<__main__.Point object at 0x000002641E574B90>
<__main__.Point object at 0x000002641E574B90>
```
`super()` - ссылка на базовый класс, в котором вызывается такой же метод `__new__` и ему передается ссылка `cls` на текущий класс (как объект) Point, экземпляр которого мы хотим создать.

В Python 3 все классы автоматически и неявно наследуются от базового класса Object.
`super().__new__(cls)`:
- `super()` - получаем ссылку на базовый класс Object
- `.__new__(cls)` в базовом классе вызывается метод `__new__`, который запускает процесс процесс создания экземпляра класса (определенного ссылкой `cls`) и возвращает адрес нового созданного объекта `self`.

## Singletone
Пример- класс `DataBase`- база данных. В программе должен существовать только один экземпляр класса.
```python
db = DataBase('root','1234',80)
db2 = DataBase('root2','5678',40)
```
При выполнении этих инструкций в результате не создается новый объект, а возвращается ссылка на ранее созданный db.

Для этого вводится аттрибут `__instance = None` который будет ссылкой на экземпляр и будет проверятся в методе `__new__`.
```python
class DataBase:
    __instance = None

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance

    def __del__(self):
        DataBase.__instance = None
```
И также переобпределили метод `__del__` (после удаления объекта, инстанс обнулится и мы сможем создавать другие экземпляры)

Но в данном случае при создании нового объекта, хоть и не будет создаваться новый экземпляр- но локальные свойства старого "затруться" новыми данными.

Чтобы это исправить надо переопределять `__call__`


