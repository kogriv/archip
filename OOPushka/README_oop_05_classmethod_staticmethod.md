в Python помимо таких «стандартных» методов можно задавать методы уровня класса и статические методы с помощью встроенных декораторов:

@classmethod и @staticmethod 

## Методы класса
```python
class Vector:
    MIN_COORD = 0
    MAX_COORD = 100

    @classmethod
    def validate(cls, arg):
        return cls.MIN_COORD <= arg <= cls.MAX_COORD
```

у методов класса (когда мы используем декоратор classmethod) первым параметром идет cls – ссылка на класс, а не self – ссылка на объект класса. Это означает, что данный метод может обращаться только к атрибутам текущего класса, но не к локальным свойствам его экземпляров. Мало того, этот метод можно теперь напрямую вызывать из класса, не передавая ссылку на экземпляр, как это было при вызове обычных методов через клас.

```python
res = Vector.validate(5)
print(res)
```
Методами класса можно пользоваться внутри других (обычных) методов определяемых в классе
```python
   def __init__(self, x, y):
        self.x = self.y = 0
        if Vector.validate(x) and Vector.validate(y):
            self.x = x
            self.y = y
```
Мы здесь обращаемся к методу класса через пространство имен Vector. Но также можем прописать и self
```python
if self.validate(x) and self.validate(y):
```
В этом случае интерпретатор Python сам подставит нужный класс в параметр cls данного метода, так как экземпляр содержит информацию о классе, от которого был образован.  Правильнее ставить `self` для избежания ошибок при переименовании классов

У метода класса (в данном случае - `validate()`) нет в ссылки на объекты класса, поэтому такие методы не могут менять свойства объектов.

## Статические методы
Это методы, которые не имеют доступа ни к атрибутам класса, ни к атрибутам его экземпляров, то есть, некая независимая, самостоятельная функция, объявленная внутри класса. Как правило- это некая вспомогательная, сервисная функция.

```python
    @staticmethod
    def norm2(x, y):
        return x*x + y*y
```
Здесь нет никаких скрытых параметров, которые бы автоматически заполнялись интерпретатором языка. Только те, что мы прописываем сами.
Воспользоваться этим методом можно как вне класса:
```python
res = Vector.norm2(5, 6)
```
Так и внутри класса:
```python
    def __init__(self, x, y):
        self.x = self.y = 0
        if self.validate(x) and self.validate(y):
            self.x = x
            self.y = y
 
        print(Vector.norm2(self.x, self.y))
```
Либо, также обратиться к этому методу через self:
```python
print(self.norm2(self.x, self.y))
```
Если вам нужен метод, который работает с атрибутами объектов класса, то это обычное определение функций внутри класса с первым параметром self. Если метод работает только с атрибутами класса, то возможно, имеет смысл его определить как метод класса и тогда его можно будет вызывать без ссылки на объект этого класса. Третий тип, статические методы часто определяют как вспомогательные, сервисные, связанные с логикой работы самого класса.