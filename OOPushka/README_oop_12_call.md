Как вы уже знаете, после объявления любого класса:

```python
class Counter:
    def __init__(self):
        self.__counter = 0
```

Мы можем создавать его экземпляры командой:
```python
c = Counter()
```
Обратите внимание на круглые скобки после имени класса. В общем случае – это оператор вызова, например, так можно вызывать функции. Но, как видите, так можно вызывать и классы. В действительности, когда происходит вызов класса, то автоматически запускается магический метод `__call__` и в данном случае он создает новый экземпляр этого класса

Упрощенная схема вызова:
```python
__call__(self,*args,*kwargs):
    obj = self.__new__(self,*args,*kwargs)
    self.__init__(obj,*args,*kwargs)
    return obj
```
То есть, класс можно вызывать подобно функции благодаря встроенной для него реализации магического метода `__call__`. А вот экземпляры классов так вызывать уже нельзя.

Но мы можем поправить этот момент, если явно в классе пропишем магический метод `__call__`
```python
class Counter:
    def __init__(self):
        self.__counter = 0
 
    def __call__(self, *args, **kwargs):
        print("__call__")
        self.__counter += 1
        return self.__counter
```
В нашем случае метод __call__ возвращает значение счетчика, поэтому с объектом можно работать, следующим образом:
```python
c = Counter()
c()
c()
res = c()
print(res)
```

## Пример - замыкание функций
Несколько примеров использования.

Первый пример – это использование класса с методом `__call__` вместо замыканий функций. Мы можем объявить класс StripChars, который бы удалял вначале и в конце строки заданные символы:
```python
class StripChars:
    def __init__(self, chars):
        self.__chars = chars
 
    def __call__(self, *args, **kwargs):
        if not isinstance(args[0], str):
            raise ValueError("Аргумент должен быть строкой")
 
        return args[0].strip(self.__chars)
```
Для этого, в инициализаторе мы сохраняем строку `__chars` – удаляемые символы, а затем, при вызове метода `__call__` удаляем символы через строковый метод strip для символов `__chars`. То есть, теперь можно создать экземпляр класса и указать те символы, которые следует убирать:
```python
s1 = StripChars("?:!.; ")
```
А, затем, вызвать объект s1 подобно функции:
```python
res = s1(" Hello World! ")
print(res)
```
В результате объект s1 будет отвечать за удаление указанных символов в начале и конце строки. Но нам ничто не мешает определять другие объекты этого класса с другим набором символов:
```python
s1 = StripChars("?:!.; ")
s2 = StripChars(" ")
res = s1(" Hello World! ")
res2 = s2(" Hello World! ")
print(res, res2, sep='\n')
```
То есть, объект s2 уже отвечает только за удаление пробелов, тогда как s1 и некоторых других символов.

## Пример - классы-декораторы

Второй пример – это реализация декораторов с помощью классов. Создадим декоратор для вычисления значения производной функции в определенной точке x.
```python
class Derivate:
    def __init__(self, func):
        self.__fn = func
 
    def __call__(self, x, dx=0.0001, *args, **kwargs):
        return (self.__fn(x + dx) - self.__fn(x)) / dx
```
Здесь в инициализаторе сохраняем ссылку на функцию, которую декорируем, а в методе `__call__` принимаем один обязательный параметр `x` – точку, где вычисляется производная и `dx` – шаг изменения при вычислении производной.

Далее, определим функцию, например, просто синус:
```python
def df_sin(x):
    return math.sin(x)
```
и вызове ее пока без декорирования:
```python
print(df_sin(math.pi/4))
```
После запуска программы увидим значение примерно 0.7071. Давайте теперь добавим декоратор. Это можно сделать двумя способами. Первый, прописать все в явном виде:
```python
df_sin = Derivate(df_sin)
```
Теперь df_sin – это экземпляр класса Derivate, а не исходная функция. Поэтому, когда она будет вызываться, то запустится метод `__call__` и вычислится значение производной в точке `math.pi/4`.

Второй способ – это воспользоваться оператором `@` перед объявлением функции:
```python
@Derivate
def df_sin(x):
    return math.sin(x)
```
Получим абсолютно тот же самый результат. Вот принцип создания декораторов функций на основе классов. Как видите, все достаточно просто – запоминаем ссылку на функцию, а затем, расширяем ее функционал в магическом методе `__call__`. 

## Декораторы с параметрами
На примере задачи курса.
:::::::::::::::::::::::::::::::::::::::::::::::
Необходимо объявить класс-декоратор с
именем Handler, который можно было бы
применять к функциям следующим образом:
```python
@Handler(methods=('GET', 'POST')) # по умолчанию methods = ('GET',)
def contact(request):
    return "Сергей Балакирев"
```
Здесь аргумент `methods` декоратора
`Handler` содержит список разрешенных
запросов для обработки. Сама декорированная
функция вызывается по аналогии с предыдущим
подвигом:
```python
res = contact({"method": "POST", "url": "contact.html"})
```
В результате функция contact должна
возвращать строку в формате:

"<метод>: <данные из функции>"
:::::::::::::::::::::::::::::::::::::::::::::::

В данном случае аргументы декоратора необходимо передавать в инициализатор класса-декоратора. А саму декорируемую функцию в виде имени - передавать как аргумент в метод `__call__`. Где уже необходимо создавать обертку над декорируемой функцией и метод `__call__` будет возвращать имя обертки.

```python
class HandlerGET:
    # аргументы можно передавать в декоратор
    def __init__(self, methods=('GET',)):
        self.__methods = methods

    # в данном примере метод __call__
    # будет полноценным декоратором,
    # т.е. будет принимать имя функции как
    # аргумент и оборачивать эту функцию
    def __call__(self, func, *args, **kwargs):
        def wrapper(request):
            m = request.get('method','GET')
            if m in self.__methods:
                method = m.lower()
                # получим атрибут класса с именем method,
                # а это будет метод класса GET или POST
                # self.__getattribute__(method) - ссылка на метод
                # и применим его к func и request
                return self.__getattribute__(method)(func,request)
        return wrapper
```
