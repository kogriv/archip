# 3
# Объявите класс PrimaryKey, который
# должен работать совместно с менеджером
# контекста следующим образом:
#
# with PrimaryKey() as pk:
#     raise ValueError
#
# где pk - ссылка на объект класса PrimaryKey.
# Класс PrimaryKey должен в момент входа в
# менеджер контекста выводить на экран
# сообщение "вход", а при завершении работы
# менеджера контекста выводить тип
# возникшего исключения.
#
# Класс PrimaryKey следует реализовать так,
# чтобы менеджер контекста сам обрабатывал
# возникшее исключение.

# здесь объявляйте класс PrimaryKey
# class PrimaryKey:
#     def __enter__(self):
#         print("вход")
#         return self
#
#     def __exit__(self, exc_type, exc_value, traceback):
#         if exc_type is not None:
#             print(exc_type)
#             return True
# with PrimaryKey() as pk:
#     raise ValueError

# 4
# Вам поручено разработать класс DatabaseConnection
# для управления подключением к базе данных.
# Объекты этого класса создаются командой:
#
# conn = DatabaseConnection()
#
# В самом классе необходимо объявить метод:
#
# def connect(self, login, password): ...
#
# для подключения к БД. В данной реализации
# этот метод должен устанавливать локальный
# атрибут _fl_connection_open в значение True:
#
# _fl_connection_open = True
#
# и генерировать исключение с помощью
# собственного класса ConnectionError
# унаследованного от базового класса Exception.
#
# Также в классе DatabaseConnection должен быть метод:
#
# def close(self): ...
#
# для закрытия соединения. В этом методе
# нужно атрибут _fl_connection_open установить в значение False.
#
# Метод close() необходимо вызывать всякий
# раз после завершения работы с БД, вне
# зависимости от того, произошли какие-либо
# исключения или нет.
#
# Этот функционал (автоматическое закрытие
# соединения с БД) предполагается реализовывать
# посредством менеджера контекста с использованием
# класса DatabaseConnection следующим образом:
#
# with DatabaseConnection() as conn:
#     # операторы менеджера контекста
#
# Пропишите дополнительно в классе DatabaseConnection
# необходимые магические методы для такого
# его использования совместно с оператором with.
#
# P.S. В программе нужно объявить только
# класс. На экран ничего выводить не нужно

# class ConnectionError(Exception):
#     pass
#
# class DatabaseConnection:
#     def __init__(self):
#         self._fl_connection_open = False
#
#     def connect(self, login, password):
#         self._fl_connection_open = True
#         raise ConnectionError("Connection Error")
#
#     def close(self):
#         self._fl_connection_open = False
#
#     def __enter__(self):
#         return self
#
#     def __exit__(self, exc_type, exc_value, traceback):
#         self.close()
#
# c = DatabaseConnection()
#
# try:
#     c.connect('aaa', 'bbb')
# except ConnectionError:
#     assert c._fl_connection_open
# else:
#     assert False, "не сгенерировалось исключение ConnectionError"
#
# try:
#     with DatabaseConnection() as conn:
#         conn.connect('aaa', 'bbb')
# except ConnectionError:
#     assert True
# else:
#     assert False, "не сгенерировалось исключение ConnectionError"
#
# assert conn._fl_connection_open == False, "атрибут _fl_connection_open принимает значение True, а должно быть False"

# 5
# Объявите класс Box (ящик), объекты
# которого создаются командой:
#
# box = Box(name, max_weight)
#
# где
# name - название ящика (строка);
# max_weight - максимальный суммарный вес
#   вещей в ящике (любое положительное число).
#
# В каждом объекте этого класса должны
# формироваться локальные атрибуты:
#
# _name - ссылка на параметр name;
# _max_weight - ссылка на параметр max_weight;
# _things - список из вещей, хранящиеся
#       в ящике (изначально пустой список).
#
# В классе Box объявите метод:
#
# def add_thing(self, obj)
#
# для добавления новой вещи в
# ящик, где obj - кортеж из двух значений:
#
# (название_вещи, вес_вещи)
#
# Если в момент добавления новой
# вещи суммарный вес всех вещей в ящике
# становится больше величины _max_weight,
# то генерировать исключение командой:
#
# raise ValueError('превышен суммарный вес вещей')
#
# Затем, объявите еще один класс
# BoxDefender, который должен работать
# совместно с менеджером контекста
# следующим образом (эти строчки
# в программе не писать):
#
# box = Box("сундук", 1000)
# box.add_thing(("спички", 46.6))
# box.add_thing(("рубашка", 134))
#
# with BoxDefender(box) as b:
#     b.add_thing(("зонт", 346.6))
#     b.add_thing(("шина", 500))
#     ...
#
# Здесь
# b - это ссылка на объект класса Box.
# Если при добавлении вещей возникает
# исключение ValueError, то объект box
# должен оставаться без изменений (с теми
# вещами, что были до вызова менеджера
# контекста). Иначе, все добавленные
# вещи остаются в объекте box.
#
# P.S. В программе только объявить классы.
# Выводить что-либо на экран и использовать классы не нужно.

# class Box:
#     def __init__(self, name, max_weight):
#         self._name = name
#         self._max_weight = max_weight
#         self._things = []
#
#     def add_thing(self, obj):
#         thing_name, thing_weight = obj
#         if sum([item[1] for item in self._things]) + thing_weight > self._max_weight:
#             raise ValueError('превышен суммарный вес вещей')
#         self._things.append(obj)
#
#
# class BoxDefender:
#     def __init__(self, box):
#         self._box = box
#         self._original_things = list(box._things)
#
#     def __enter__(self):
#         return self._box
#
#     def __exit__(self, exc_type, exc_value, traceback):
#         if exc_type is not None:
#             self._box._things = self._original_things
#
#
# b = Box('name', 2000)
# assert b._name == 'name' and b._max_weight == 2000, "неверные значения атрибутов объекта класса Box"
#
# b.add_thing(("1", 100))
# b.add_thing(("2", 200))
#
# try:
#     with BoxDefender(b) as bb:
#         bb.add_thing(("3", 1000))
#         bb.add_thing(("4", 1900))
# except ValueError:
#     assert len(b._things) == 2
#
# else:
#     assert False, "не сгенерировалось исключение ValueError"
#
# try:
#     with BoxDefender(b) as bb:
#         bb.add_thing(("3", 100))
# except ValueError:
#     assert False, "возникло исключение ValueError, хотя, его не должно было быть"
# else:
#     assert len(b._things) == 3, "неверное число элементов в списке _things"

# Имеется следующий фрагмент программы:
#
# class PrinterError(Exception):
#     """Класс общих ошибок принтера"""
#
#
# class PrinterConnectionError(PrinterError):
#     """Ошибка соединения с принтером"""
#
#
# class PrinterPageError(PrinterError):
#     """Ошибка отсутствия бумаги в принтере"""
#
#
# try:
#     raise PrinterConnectionError('соединение с принтером отсутствует')
# except (PrinterConnectionError, PrinterPageError) as e:
#     print(e)
# except PrinterError as e:
#     print(e)
#
# Выберите все верные утверждения, связанные с этой программой.

# блок except с двумя классами PrinterConnectionError
# и PrinterPageError записывать нельзя, возникнет ошибка?
#
# Нет, это не верно. Блок except с двумя классами,
# PrinterConnectionError и PrinterPageError, может
# быть записан, и он будет работать без ошибок.
# В Python блок except может обрабатывать
# несколько исключений, указывая их в
# скобках через запятую.
#
# Таким образом, блок except будет перехватывать
# оба типа исключений: PrinterConnectionError и
# rinterPageError. В данном случае, если была
# вызвана ошибка PrinterConnectionError, код
# в блоке except сработает и выведет
# сообщение, переданное при вызове исключения.
# "соединение с принтером отсутствует"
#
# при выполнении программы на экране
# будет отображена строка "соединение
# с принтером отсутствует"?
#
# Да, при выполнении программы на экране
# будет отображена строка "соединение с
# принтером отсутствует". Это произойдет
# потому, что при выполнении кода в блоке
# try, возникает исключение
# PrinterConnectionError с сообщением
# 'соединение с принтером отсутствует'.
# Затем этот код перехватывается блоком except,
# который обрабатывает исключения
# PrinterConnectionError и PrinterPageError.
# В результате будет выполнен блок except
# (PrinterConnectionError, PrinterPageError)
# as e, который выводит сообщение,
# переданное при вызове исключения.
#
# при возникновении исключений
# PrinterConnectionError или PrinterPageError
# выполнение программы перейдет в блок
# except с этими двумя классами
#
# Да, при возникновении исключений
# PrinterConnectionError или PrinterPageError
# выполнение программы перейдет в блок except
# с этими двумя классами. Это потому, что оба
# этих класса являются подклассами базового
# класса PrinterError. Когда происходит
# исключение типа PrinterConnectionError
# или PrinterPageError, оно также является
# типом PrinterError, и поэтому может быть
# обработано в блоке except с классом PrinterError.
# В данном случае, блок
# except (PrinterConnectionError, PrinterPageError) as e
# будет обрабатывать исключения обоих классов,
# в том числе и выводить сообщение,
# переданное при вызове исключения.
#
# последний блок except с классом
# PrinterError никогда выполнен не
# будет ни при каких типах исключений?
#
# В данном случае последний блок except с
# классом PrinterError не будет выполнен,
# если уже был выполнен один из предыдущих
# блоков except, так как исключение будет
# обработано в первом соответствующем блоке
# except, который обрабатывает подклассы
# PrinterConnectionError и PrinterPageError.
#
# Однако, если возникнет исключение, которое
# является экземпляром класса PrinterError,
# но не является экземпляром ни PrinterConnectionError,
# ни PrinterPageError, то этот блок except с
# классом PrinterError будет выполнен.
#
# В текущем контексте, если бы вы добавили код,
# где исключение было бы экземпляром PrinterError,
# но не было бы экземпляром ни PrinterConnectionError,
# ни PrinterPageError, то этот блок except с
# классом PrinterError мог бы быть выполнен.

# Возможно ли в ООП обойтись без механизма
# обработки исключений и менеджеров контекста
#
# да, но программа может получиться
# трудно понимаемой и трудно расширяемой
#
# Да, в целом, вы можете написать программу
# без использования механизма обработки
# исключений и менеджеров контекста
# в объектно-ориентированном программировании (ООП).
# Однако, их отсутствие может усложнить
# обработку ошибок и управление ресурсами,
# так как вы будете вынуждены использовать
# другие методы для обработки ошибок и
# управления ресурсами в вашей программе.
#
# Использование механизма обработки исключений
# и менеджеров контекста упрощает обработку
# ошибок и управление ресурсами, делая код
# более читаемым, понятным и поддерживаемым.
# Механизм обработки исключений позволяет
# эффективно управлять исключительными
# ситуациями, а менеджеры контекста
# обеспечивают безопасное и эффективное
# управление ресурсами, такими как файлы
# или сетевые соединения.
#
# Использование этих механизмов в ООП
# позволяет создавать более надежный и
# устойчивый код, что облегчает разработку,
# отладку и сопровождение программ.
#
# без менеджеров контекста невозможно
# обрабатывать ошибки при работе с файлами
#
# В общем нет. НО
# без использования менеджеров контекста
# обработка ошибок при работе с файлами может
# быть затруднительной. Менеджеры контекста
# в Python, такие как with, обеспечивают
# автоматическое открытие и закрытие файлов,
# что гарантирует корректное освобождение
# ресурсов, даже если возникают ошибки
# в процессе выполнения.
#
# Без использования менеджеров контекста,
# вам нужно было бы явно открывать файлы,
# выполнять операции с ними и затем явно
# закрывать их в блоках try и finally.
# Это может привести к утечкам ресурсов
# и нестабильному поведению программы
# при возникновении ошибок, таких как
# исключения или прерывания.
#
# Поэтому, хотя вы можете избежать
# использования менеджеров контекста,
# это не рекомендуется, особенно при
# работе с файлами, поскольку
# использование менеджеров контекста
# упрощает обработку ошибок и управление
# ресурсами, делая ваш код более
# безопасным и надежным.
#
#