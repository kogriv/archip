Функция super() используется для получения доступа к методам родительского класса в наследуемом классе. Она предоставляет универсальный способ получения доступа к родительскому классу, не явно указывая его имя, что делает код более устойчивым к изменениям в иерархии наследования.

super() может принимать два аргумента:

- super() - без аргументов. Эта форма используется, когда вам нужен доступ к родительским методам без явного указания родительского класса. Она возвращает объект прокси, который делегирует вызовы методов родительского класса. Этот вариант часто используется при множественном наследовании, когда необходимо явно указать родительский класс для вызова методов.

- super(type, object) - с двумя аргументами. Эта форма используется, когда вам нужно получить доступ к методам родительского класса вне методов экземпляра. Она позволяет получить доступ к методам родительского класса, даже если иерархия наследования множественная.

Пример использования с аргументами:
```python
class StringDigit(str):
    def __new__(cls, string):
        if not string.isdigit():
            raise ValueError("в строке должны быть только цифры")
        return super(StringDigit, cls).__new__(cls, string)

    def __add__(self, other):
        if not isinstance(other, str) or not other.isdigit():
            raise ValueError("в строке должны быть только цифры")
        return StringDigit(super().__add__(other))

    def __radd__(self, other):
        if not isinstance(other, str) or not other.isdigit():
            raise ValueError("в строке должны быть только цифры")
        return StringDigit(other + str(self))
```

Использование `super(StringDigit, cls).__new__(cls, string)` обеспечивает вызов метода `__new__` базового класса `str` с переданным аргументом `string` для создания нового экземпляра `StringDigit`.
Это позволяет корректно и явно вызвать метод `__new__` базового класса `str`, чтобы создать новый экземпляр `StringDigit` с нужным поведением.

