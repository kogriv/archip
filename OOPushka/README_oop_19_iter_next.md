## Общее описание
Протокол итераторов реализуется всем встроенными коллекциями, а также например, файлами и объектами типа `map`, `filter`, `zip`.
Последовательности - индексированы. Итераторы - нет, т.е. по индексу мы не получим доступ к итерируемым значениям.
- Итераторы работают лениво, т.е. не выполняют какой-либо работы, пока не используются. Так можно создавать бесконечные последовательности.

Базовые классы:
- Iterable - все у чего есть метод `__iter__`, который порождает (возвращает) сам итератор (self - как правило)- экземпляр класса, реализующего протокол итератора. Это могут быть не только стандартные контейнеры-последовательности (такие как списки, кортежи..). При возникновении исключения TypeError при передаче какого то объекта в iter- это значит не итерэбл
- Iterator - порождается методом `__iter__` из класса Iterable. Имеет метод `__next__`, который возвращает следующий элемент итератора (или исключение StopIteration), все последующие после исключения вызовы next будут также поднимать исключение. next(obj) -> TypeError не итератор.

```python
class Iterable:
    def __iter__(self):
        return Iterator()

class Iterator:
    def __next__(self):
        if self.has_more_elements():
            return self.next_element()
        raise StopIteration

it = Iterator()
elem = next(it, default)
```
Является хорошим тоном делать итераторы Iterable с такой семантикой, что метод `__iter__` возвращает его самого:
```python
class Iterator:
    def __next__(self):
        ...
    def __iter__(self):
        return self
```
При разделении на Iterator и  Iterable мы можем получить (всегда) "одноразовый" итератор. Это нужно потому, что не по всем вещам мы можем проитерироваться 2 раза (например, мы читаем байты из сети- их нельзя запихнуть обратно).
В общем случае всегда Iterator is Iterable (в отличие от Java напр.)

У функции `iter` есть 2 формы вызова:
- принимает итерэбл и вызывает у него метод `__iter__`
- принимает функцию и терминальное значение и вызывает ф-ю до тех пор, пока она не вернет нужное значение:
```python
from functools import partitial
with open (path, 'rb') as handle:
    read_block = partitial(handle.read, 64)
    # читаем файл до конца ("")
    for block in iter(read_block, ''):
        do_something(block)
```

Функция `next` принимает итератор и вызывает у него метод `__next__`. Можно также указать значение, которое нужно вернуть в случе исключения.
```python
next([], 42)
```

В Питон предусмотрен упрощенный вариант реализации протокола итераторов с использованием `__getitem__`. Если объект перегружает `__getitem__`, то он автоматом становится итератором. Это - итераторы по умолчанию. Их лучше не использовать, т.к. метод `__iter__` реализуется в неявном виде.

Операторы `in` и `not in` используют `__contains__`, который возвращает `True`, если переданный элемент содержится в экземпляре класса.
По умолчанию `__contains__` реализован через протокол итераторов.

## Примеры итераторов
```python
from collections.abc import Iterable
from pprint import pprint

numbers = [1,2,3,4]
if isinstance(numbers, Iterable):
    print("Список numbers = [1,2,3,4] - наследуется от collections.abc.Iterable")
if hasattr(numbers, '__iter__'):
    print("Этот объект итерируемый - имеет атрибут __iter__")
if not hasattr(numbers, '__next__'):
    print("Этот объект НЕ итератор - не имеет атрибут __next__")
print()
```
Получим
```cmd
Список numbers = [1,2,3,4] - наследуется от collections.abc.Iterable
Этот объект итерируемый - имеет атрибут __iter__
Этот объект НЕ итератор - не имеет атрибут __next__
```

Теперь вызовем метод `__iter__` на итерируемом объекте:
```python
my_iterator = numbers.__iter__() # эквивалентная инструкция: iter(numbers)
print('my_iterator = numbers.__iter__() это',my_iterator)
if isinstance(my_iterator, Iterable):
    print("Итератор numbers.__iter__ - наследуется от collections.abc.Iterable")
if hasattr(my_iterator, '__iter__'):
    print("Этот объект итерируемый - имеет атрибут __iter__")
if hasattr(my_iterator, '__next__'):
    print("Этот объект ЕСТЬ итератор - ИМЕЕТ атрибут __next__")
print()
```
Получим
```cmd
my_iterator = numbers.__iter__() это <list_iterator object at 0x0000022ACF9DACE0>
Итератор numbers.__iter__ - наследуется от collections.abc.Iterable
Этот объект итерируемый - имеет атрибут __iter__
Этот объект ЕСТЬ итератор - ИМЕЕТ атрибут __next__
```

Вызовем `__iter__` на созданном выше итераторе `my_iterator`:
```python
new_iterator = my_iterator.__iter__()
print('new_iterator = my_iterator.__iter__() это',new_iterator)

print()
if new_iterator is my_iterator:
    pprint('Объект-итератор, созданный на основе исходной последовательности '+
          'совпадает с объектом-итератором, созданным основе объекта-итериатора')
```
Получим совпадение объектов. Это очевидно, т.к. итер должен возвращать сам себя.

Итерироваться по порождающему итэрэбл объекту  numbers можно с помощью инструкций: `new_iterator.__next__` или `next(new_iterator)` до конца последовательности = до появления исключения StopIteration

Инструкция for работает так:
Сначала из итэрэбл создается итератор путем вызова `__iter__`. Потом "выстреливает" обойма `__next__` до появления исключения. Метод `next(iterator_in_for)` возвращает значение из итэрэбл (из последовательности) и присваивает его переменной-варианте например, i, цикла.

## Свой итератор
Можно создавать отдельно классы iterable (без некст) и класс-итератор
Можно - совмещать. Ниже пример совмещенного класса.
```python
class HellowWorld:
    def __init__(self, num_iters):
        self.num_iters = num_iters
        self.counter = 0

    # __iter__ возвращает объект своего класса
    # поскольку сам уже является итератором
    # т.к. __next__ будет определен в классе также
    def __iter__(self):
        return self

    def __next__(self):
        if self.counter < self.counter:
            self.counter += 1
            return "Hello World"
        raise StopIteration

print()
greeter = HellowWorld(3)
print('greeter = HellowWorld(3) это',greeter)

print()
print('greeter.__iter__() это',greeter.__iter__())
if isinstance(greeter, Iterable):
    print("Итератор greeter - наследуется от collections.abc.Iterable")
if hasattr(greeter, '__iter__'):
    print("Этот объект итерируемый - имеет атрибут __iter__")
if hasattr(greeter, '__next__'):
    print("Этот объект ЕСТЬ итератор - ИМЕЕТ атрибут __next__")
```
Получим:
```cmd
ример кастомного итератора. Класс HellowWorld:

greeter = HellowWorld(3) это <__main__.HellowWorld object at 0x0000022ACFC10F10>

greeter.__iter__() это <__main__.HellowWorld object at 0x0000022ACFC10F10>
Итератор greeter - наследуется от collections.abc.Iterable
Этот объект итерируемый - имеет атрибут __iter__
Этот объект ЕСТЬ итератор - ИМЕЕТ атрибут __next__
```
Видим, что `greeter` и `greeter.__iter__` - один объект - итератор

## Генератор - наследник итератора
```python
def string_by_letter(string):
    for letter in string:
        yield letter.upper()

gen = string_by_letter('Some string')
print("gen = string_by_letter('Some string') это:",gen)
print('gen.__iter__() это',gen.__iter__())
if isinstance(gen, Iterable):
    print("Итератор gen - наследуется от collections.abc.Iterable")
if hasattr(gen, '__iter__'):
    print("Этот объект итерируемый - имеет атрибут __iter__")
if hasattr(gen, '__next__'):
    print("Этот объект ЕСТЬ итератор - ИМЕЕТ атрибут __next__")
print()
```
Зачастую проще (лаконичней) создавать генераторы в виде вункций, чем реализовывать громоздкий класс-итератор.

## Запоминание места
В некотором смысле, итератор "знает", где он находится в коллекции и какие элементы уже были возвращены, но это реализовано неявно. Когда вы создаете итератор в Python с помощью функций, таких как map, filter или с помощью ключевого слова yield в определении функции-генератора, внутренняя логика итератора поддерживает состояние прохода через элементы.

В случае с map в Python, итератор создается таким образом, что он знает, какой элемент следует возвращать при каждом вызове метода next(). После того как итератор вернул следующий элемент, он "запоминает" этот факт, чтобы знать, что в следующий раз нужно вернуть следующий элемент после текущего.

Точные детали реализации могут зависеть от конкретной реализации Python, но в целом итераторы создаются таким образом, что они сохраняют информацию о текущем состоянии прохода через коллекцию, чтобы могли вернуть следующий элемент при каждом вызове next().

## Iterable
В Python итерируемые объекты (iterables) - это объекты, которые можно использовать в цикле for. Они представляют собой контейнеры, которые содержат последовательность значений. К ним относятся списки, кортежи, словари, строки и другие типы контейнеров.

Классы могут стать итерируемыми, если они реализуют метод `__iter__`, который возвращает итератор. Метод `__iter__` может возвращать любой объект, который реализует метод `__next__` (для создания итератора). Это позволяет классам контролировать свое поведение при итерации через объекты этого класса.

Чтобы определить, является ли объект итерируемым, можно использовать функцию iter() над объектом и проверить, вызывается ли `__iter__` у этого объекта. Например:

```python

my_list = [1, 2, 3, 4, 5]

# Проверка, является ли объект итерируемым
if hasattr(my_list, '__iter__'):
    print("Этот объект итерируемый")
```
Кроме того, можно использовать функцию `isinstance()` для проверки, является ли объект экземпляром итерируемого класса:

```python

if isinstance(my_list, Iterable):
    print("Этот объект итерируемый")
```
Здесь `Iterable` - это абстрактный базовый класс из модуля `collections.abc`, который представляет все итерируемые классы в Python.

## iterable vs iterator
Создавая контейнер-последовательность, получаем в списке методов `__iter__` но не получаем `__next__`. Т.о. получаем итерируемый объект. Т.е. объект, "обладающий свойством" iterable (наследуемый от `Iterable`)

## Разбор итератора от Elena Vedeneva
С форума курса Сергея Балакирева

При всём уважении к автору, тема действительно раскрыта не достаточно подробно.
Как минимум никак не упоминается критически важный нюанс (возможно предполагалось, что это и так должно быть очевидно, но это не очевидно😕), при таком подходе мы не можем получить несколько независимых друг от друга итераторов, так как они все будут ссылаться на один и тот же объект и, соответственно, значения в их атрибутах будут меняться одновременно.
Что я имею в виду? Что если мы возьмём реализацию класса FRange, которая приведена в уроке, а затем попытаемся сделать так:
```python
fr = FRange(0, 2, 0.5)
it1 = iter(fr)
it2 = iter(fr)
```
Объекты it1 и it2 будут ссылаться на один и тот же объект fr. И такая последовательность вызовов, даст нам следующий вывод:
```python
print(next(it1))  # 0.0
print(next(it1))  # 0.5
print(next(it2))  # 1.0 - wait, what?! я же вызывала it2...
print(next(it2))  # 1.5 - oykeeeey
```
Исходя из видео такой вывод сделать конечно можно, но это не является самоочевидным, если не задуматься об этом целенаправленно. Ведь функция `iter()` сама по себе не генерирует новый объект, она только вызывает метод `__iter__` для объекта, а там уже всё зависит от реализации этого метода в конкретном классе.

Окей, как же тогда быть, если мы хотим получить всё же корректно работающий метод `__iter__`, который позволит создавать нам не взаимосвязанные между собой итераторы?
На самом деле есть целых три способа!
1) Класс, который управляет логикой методов `__iter__` и `__next__` создаётся отдельно, а в исходном классе, в методе `__iter__` мы возвращаем ссылку на объект класса итератора!
```python
class FRangeIterator:
    def __init__(self, start, stop, step):
        self.current = start - step
        self.stop = stop
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        self.current += self.step
        if self.current < self.stop:
            return self.current
        else:
            raise StopIteration


class FRange:
    def __init__(self, start=0.0, stop=0.0, step=1.0):
        self.start = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        return FRangeIterator(self.start, self.stop, self.step)


fr = FRange(0, 2, 0.5)
it1 = iter(fr)
it2 = iter(fr)
print(next(it1))  # 0.0
print(next(it1))  # 0.5
print(next(it2))  # 0.0
print(next(it2))  # 0.5
```
При такой реализации it1 и it2 будут ссылаться на два разных объекта и параллельная работа с ними не будет приводить к ошибкам, ибо для каждого из них хранится своё пространство значений!

2) Второй способ основан на работе генератора yield. Генераторы позволяют создавать итерируемые объекты с отложенным вычислением значений. В методе `__iter__` генератор yield используется для возврата значений в процессе итерации, но при этом сохраняется текущее состояние функции.
```python
class FRange:
    def __init__(self, start=0.0, stop=0.0, step=1.0):
        self.start = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        value = self.start - self.step
        while value + self.step < self.stop:
            value += self.step
            yield value


fr = FRange(0, 2, 0.5)
it1 = iter(fr)
it2 = iter(fr)
print(next(it1))  # 0.0
print(next(it1))  # 0.5
print(next(it2))  # 0.0
print(next(it2))  # 0.5
```
Почему в таком случае нам не нужно прописывать метод `__next__`?

Когда `yield` используется внутри метода `__iter__`, он преобразует класс в генератор. Внутренне Python создает класс, реализующий методы `__iter__` и `__next__`, а также управляет состоянием выполнения функции-генератора таким образом, что он запоминает свое состояние между вызовами `next()`.

При каждом вызове `next()`, выполнение функции-генератора (точнее, его внутреннего состояния) возобновляется с последнего `yield`, и значение `yield` становится результатом вызова `next()`. Если генератор завершил свою работу, возбуждается исключение `StopIteration`.
...

3) В Python итерируемыми считаются объекты, которые реализуют метод `__iter__()`, возвращающий итератор, либо метод `__getitem__()`, который позволяет получить элементы последовательности по индексу. Что это значит?
При использовании цикла for (или функции iter()) в Python первоочередно вызывается метод `__iter__()`. Если объект имеет метод `__iter__()`, он будет вызван для создания итератора. Если объект не имеет метода `__iter__()`, но имеет метод `__getitem__()`, итератор будет создан на основе этого метода.
```python
class FRange:
    def __init__(self, start=0.0, stop=0.0, step=1.0):
        self.start = start
        self.stop = stop
        self.step = step

    def __len__(self):
        return int((self.stop - self.start) // self.step)

    def __check_indx(self, indx):
        if not (0 <= indx < len(self)):
            raise IndexError

    def __getitem__(self, indx):
        self.__check_indx(indx)
        return self.start + self.step * indx


fr = FRange(0, 2, 0.5)
it1 = iter(fr)
it2 = iter(fr)
print(next(it1))  # 0.0
print(next(it1))  # 0.5
print(next(it2))  # 0.0
print(next(it2))  # 0.5
```
И последний важный момент!

Основная фишка итераторов заключается в том, что он не генерирует всю последовательность целиком, а рассчитывает и выдаёт значения постепенно! Поэтому подход, в котором в методе `__iter__` прописывается какой-то цикл или генератор списка или ещё какой-то функционал, создающий сразу всю последовательность, а значения выдаются уже через `__next__` или с помощью `yield `в самом методе `__iter__` поочерёдно является в корне не верным! Так как при работе с большим массивом данных, выполнение метода `__iter__`, в котором будет генерироваться сразу вся последовательность просто загнёт вашу программу.
То есть как-то так делать не надо!!)) Работать будет корректно, но весь смысл итератора в таком случае идёт коту под хвост...
```python
class FRange:
    def __init__(self, start=0.0, stop=0.0, step=1.0):
        self.start = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        values = [self.start + self.step * i for i in range(int((self.stop - self.start) / self.step))]
        for value in values:
            yield value
```
