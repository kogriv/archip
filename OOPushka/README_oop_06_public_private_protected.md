Конспект материалов Сергея Балакирева
https://proproprogs.ru/python_oop/rezhimy-dostupa-public-private-protected-settery-i-gettery

## Варианты доступа к данным
В Python возможны следующие варианты доступа к данным:

- `attribute` (без одного или двух подчеркиваний вначале) – публичное свойство (public);
- `_attribute` (с одним подчеркиванием) – режим доступа protected (служит для обращения внутри класса и во всех его дочерних классах)
- `__attribute` (с двумя подчеркиваниями) – режим доступа private (служит для обращения только внутри класса). 

## 1-но подчеркивание
Нижнее подчеркивание должно предостерегать программиста от использования этого свойства вне класса. Впоследствии это может стать причиной непредвиденных ошибок. Например, изменится версия класса и такое свойство может перестать существовать, т.к. никто не предполагал доступа к нему извне. Так что, к таким атрибутам лучше не обращаться напрямую – одно нижнее подчеркивание указывает нам, что это внутренние, служебные переменные.

# 2 подчеркивания
Давайте теперь посмотрим, как работает режим доступа private. Пропишем у локальных свойств два подчеркивания:

'''python
class Point:
    def __init__(self, x=0, y=0):
        self.__x = x
        self.__y = y
'''

и также попробуем обратиться к ним напрямую:
'''python
print(pt.__x, pt.__y)
'''
После запуска программы видим ошибку, что такие свойства не определены. Это говорит о том, что извне, через переменную pt мы не можем напрямую к ним обращаться. А вот внутри класса доступ к ним открыт.

## геттеры и сеттеры
Пропишем метод set_coord, который будет менять локальные свойства __x и __y экземпляра класса:
'''python
    def set_coord(self, x, y):
        self.__x = x
        self.__y = y
'''
А ниже, вызовем его для экземпляра pt:
'''python
pt.set_coord(1, 2)
'''
Как видите, никаких ошибок не возникает и чтобы убедиться в изменении локальных приватных свойств, определим еще один метод:
'''python
    def get_сoord(self):
        return self.__x, self.__y
'''
И вызовем его:
'''python
print(pt.get_сoord())
'''
После запуска программы видим измененные координаты точки. В результате, мы с вами определили два вспомогательных метода: set_coord и get_coord, через которые предполагается работа с защищенными данными класса. Такие методы в ООП называются сеттерами и геттерами или еще интерфейсными методами. 

## Валидность аргументов
Назначение интерфейсных методов не только передавать значения между приватными атрибутами класса, но и проверять их корректность. Например, в нашем случае координаты должны быть числами. Поэтому, прежде чем обновлять значения переменных, следует проверить их тип данных. Для этого можно воспользоваться функцией type и записать сеттер следующим образом:
'''pyhton
    def __init__(self, x=0, y=0):
        self.__x = self.__y = 0
 
        if self.__check_value (x) and self.__check_value (y):
            self.__x = x
            self.__y = y
 
    def set_coord(self, x, y):
        if self.__check_value (x) and self.__check_value (y):
            self.__x = x
            self.__y = y
        else:
            raise ValueError("Координаты должны быть числами")
'''

При этом необходимо определить приватный метод класса:
'''python
@classmethod
    def __check_value(cls, x):
        return type(x) in (int, float)
'''
Не забыть, что обращение к методу класса в обычном методе в классе следует делать через `self.`, а не через имя класса `Point`.

При этом в Python можно относительно легко обратиться и к приватным атрибутам извне. Если распечатать все атрибуты экземпляра:
'''python
print(dir(pt))
'''
то среди прочих мы увидим, следующие:
'''cmd
'_Point__x', '_Point__y'
'''
Это и есть кодовые имена приватных атрибутов, к которым мы можем обратиться через ссылку pt:
'''python
print(pt._Point__x, pt._Point__y)
'''
и менять их. Однако, так делать крайне не рекомендуется и двойное подчеркивание должно сигнализировать программисту, что работать с такими атрибутами нужно только через разрешенные интерфейсные методы. Иначе, возможны непредвиденные ошибки.

## accessify
Если у вас появилась необходимость лучше защитить методы класса от доступа извне, то это можно сделать с помощью модуля accessify. Для его установки нужно выполнить команду:
'''cmd
pip install accessify
'''
И, затем, импортировать из него два декоратора:
'''python
from accessify import private, protected
'''
Далее, нужный декоратор просто применяем к методу и он становится либо приватным (private), либо защищенным (protected):
'''python
    @private
    @classmethod
    def check_value(cls, x):
        return type(x) in (int, float)
'''
Все, теперь мы можем обратиться к check_value только внутри класса, но не извне.