Для подготовки документа использовались открытые видеоматериалы курсов по ООП Сергея Балакирева, Артема Егорова.

## Параметрический полиморфизм (ПП).
Есть иерархия классов: базовый [Class: Figure | Prop: Coorsd, Color, Width | Method: draw()]-> наследники базового (дети) [Class: (Line, Rect, Ellipse) | Method: draw()]. Есть объекты-экземпляры классов-наследников (например, по 2 каждого класса). Благодаря ПП, мы можем оперировать разными типами объектов через их единый базовый класс (через его интерфейс переопределнных (наследуемых) методов). Это делается путем приведения объекта наследника к базовому типу. После этого вызывается необходимый метод базового класса (draw()), который вызовет этот же метод, но переопределнный в классе наследнике в соответствии с типом объекта, который вызвал метод в базе.

Имеем классы в файле SB_001_Param_polymorph.py:
```python
class Figure:
    def __init__(self, x, y, color, width):
        self.x = x
        self.y = y
        self.color = color
        self.width = width
        # print('Figure __init__')
        logger.debug('Figure __init__')

    def draw(self):
        # print('Figure draw pass')
        logger.debug('Figure draw pass')
        pass


class Ellipse(Figure):
    def draw(self):
        msg = f"Drawing an ellipse from ({self.x}, {self.y}) with color {self.color} and width {self.width}"
        # print(msg)
        logger.debug(msg)

class AsymmetricEllipse(Ellipse):
    def draw(self):
        msg = f"Drawing an asymmetric ellipse from ({self.x}, {self.y}) with color {self.color} and width {self.width}"
        # print(msg)
        logger.debug(msg)
```
получаем вывод:
```cmd
main:<module>:20 - in __main__ way started
SB_001_Param_polymorph:__init__:15 - Figure __init__
SB_001_Param_polymorph:draw:33 - Drawing an asymmetric ellipse from (40, 40) with color green and width 3
main:main:15 - Type of asym_ellipse: <class 'SB_001_Param_polymorph.AsymmetricEllipse'>
```

В приведенном выше примере вызов метода draw() будет идти по иерархии классов, начиная с самого дочернего класса (AsymmetricEllipse) и заканчивая базовым классом (Figure). Этот процесс называется "динамическим полиморфизмом" или "полиморфизмом времени выполнения", и он позволяет вызывать версию метода, соответствующую фактическому типу объекта во время выполнения.

Вот как это происходит:

Вызывается метод draw() на объекте asym_ellipse, который имеет тип AsymmetricEllipse.

Python начинает поиск метода draw() в классе AsymmetricEllipse. Если метод найден в этом классе, то он будет выполнен, и поиск завершится. В данном случае, метод draw() найден в классе AsymmetricEllipse, и он будет выполнен.

Если бы метод draw() не был найден в классе AsymmetricEllipse, Python продолжил бы поиск в его родительском классе, который в данном случае является классом Ellipse. Если бы метод был найден там, он был бы выполнен. Если нет, Python бы продолжил поиск в базовом классе Figure.

Таким образом, в вашем примере вызывается метод draw() из класса AsymmetricEllipse, а не из базового класса Figure, потому что объект asym_ellipse имеет тип AsymmetricEllipse. Это иллюстрирует принцип полиморфизма, который позволяет различным объектам выполнять одноименные методы в соответствии с их собственными реализациями.

## Без полиморфизма / псевдонимы
Если бы в классах-потомках метод draw() был реализован с другим именем. Нам пришлось бы пользоваться инструкцией:
```python
if isinstance(some_object, some_class):
    some_object.some_class_method()
```

Для полиморфизма в Python при переопределении метода в дочернем классе необходимо сохранять сигнатуру (аргументы и имена) метода базового класса. Это означает, что метод в дочернем классе должен иметь такое же имя и такой же список аргументов, как и метод в базовом классе.

Ваш метод в дочернем классе должен иметь ту же сигнатуру, чтобы Python мог понимать, что это переопределение метода. Если сигнатура будет отличаться (например, другое количество аргументов или их разные имена), то Python не будет считать это переопределением метода, и вы получите ошибку.

Таким образом, даже если вы хотите создать псевдоним для метода базового класса, сигнатура метода в дочернем классе должна оставаться той же. Вы можете внутри этого метода вызывать метод базового класса или делать что-либо другое, но сигнатура должна совпадать.

Пример:
```python
class Line(Figure):
    def draw_line(self):  # Метод с другим именем
        print(f"Drawing a line from ({self.x}, {self.y}) with color {self.color} and width {self.width}")

    # Псевдоним для метода базового класса
    def draw(self):
        self.draw_line()
```

## Инициализация объектов классов-наследников
При этом строка вывода
```cmd
SB_001_Param_polymorph:__init__:15 - Figure __init__
```
говорит о том, что вызывается конструктор (__init__) базового класса Figure при создании экземпляра класса AsymmetricEllipse. Это происходит потому, что при создании объекта любого класса-наследника, сначала вызывается конструктор базового класса, а затем конструктор самого класса-наследника. Таким образом, Figure __init__ не относится к asym_ellipse, а относится к его базовому классу AsymmetricEllipse.

Процесс инициализации объекта наследника обычно включает в себя вызов конструктора базового класса для инициализации общих атрибутов. Это делается с помощью super().__init__(...) в конструкторе наследника. Если вы не определяете явно конструктор для класса-наследника, Python будет вызывать конструктор базового класса автоматически.

Если вам не нужно вызывать конструктор базового класса при создании экземпляра класса-наследника, вы можете определить собственный конструктор для класса-наследника и явно вызвать конструктор базового класса, если это необходимо. Например:
```python
class AsymmetricEllipse(Ellipse):
    def __init__(self, x, y, color, width):
        super().__init__(x, y, color, width)  # Явный вызов конструктора базового класса
        msg = f"Creating an asymmetric ellipse from ({x}, {y}) with color {color} and width {width}"
        logger.debug(msg)
```
Такой подход позволит вам более точно контролировать инициализацию объектов и избежать вызова конструктора базового класса, если это не требуется.
