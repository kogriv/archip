Для подготовки документа использовались открытые видеоматериалы курсов по ООП Сергея Балакирева, Артема Егорова.

## Полиморфизм (П).
Есть иерархия классов: базовый [Class: Figure | Prop: Coorsd, Color, Width | Method: draw()]-> наследники базового (дети) [Class: (Line, Rect, Ellipse) | Method: draw()]. Есть объекты-экземпляры классов-наследников (например, по 2 каждого класса). Благодаря П, мы можем оперировать разными типами объектов через их единый базовый класс (через его интерфейс переопределнных (наследуемых) методов). Это делается путем приведения объекта наследника к базовому типу. После этого вызывается необходимый метод базового класса (draw()), который вызовет этот же метод, но переопределнный в классе наследнике в соответствии с типом объекта, который вызвал метод в базе.

Имеем классы в файле SB_001_Param_polymorph.py:
```python
class Figure:
    def __init__(self, x, y, color, width):
        self.x = x
        self.y = y
        self.color = color
        self.width = width
        # print('Figure __init__')
        logger.debug('Figure __init__')

    def draw(self):
        # print('Figure draw pass')
        logger.debug('Figure draw pass')
        pass


class Ellipse(Figure):
    def draw(self):
        msg = f"Drawing an ellipse from ({self.x}, {self.y}) with color {self.color} and width {self.width}"
        # print(msg)
        logger.debug(msg)

class AsymmetricEllipse(Ellipse):
    def draw(self):
        msg = f"Drawing an asymmetric ellipse from ({self.x}, {self.y}) with color {self.color} and width {self.width}"
        # print(msg)
        logger.debug(msg)
```
получаем вывод:
```cmd
main:<module>:20 - in __main__ way started
SB_001_Param_polymorph:__init__:15 - Figure __init__
SB_001_Param_polymorph:draw:33 - Drawing an asymmetric ellipse from (40, 40) with color green and width 3
main:main:15 - Type of asym_ellipse: <class 'SB_001_Param_polymorph.AsymmetricEllipse'>
```

В приведенном выше примере вызов метода draw() будет идти по иерархии классов, начиная с самого дочернего класса (AsymmetricEllipse) и заканчивая базовым классом (Figure). Этот процесс называется "динамическим полиморфизмом" или "полиморфизмом времени выполнения", и он позволяет вызывать версию метода, соответствующую фактическому типу объекта во время выполнения.

Вот как это происходит:

Вызывается метод draw() на объекте asym_ellipse, который имеет тип AsymmetricEllipse.

Python начинает поиск метода draw() в классе AsymmetricEllipse. Если метод найден в этом классе, то он будет выполнен, и поиск завершится. В данном случае, метод draw() найден в классе AsymmetricEllipse, и он будет выполнен.

Если бы метод draw() не был найден в классе AsymmetricEllipse, Python продолжил бы поиск в его родительском классе, который в данном случае является классом Ellipse. Если бы метод был найден там, он был бы выполнен. Если нет, Python бы продолжил поиск в базовом классе Figure.

Таким образом, в вашем примере вызывается метод draw() из класса AsymmetricEllipse, а не из базового класса Figure, потому что объект asym_ellipse имеет тип AsymmetricEllipse. Это иллюстрирует принцип полиморфизма, который позволяет различным объектам выполнять одноименные методы в соответствии с их собственными реализациями.

## Без полиморфизма
Если бы в классах-потомках метод draw() был реализован с другим именем. Нам пришлось бы пользоваться инструкцией:
```python
if isinstance(some_object, some_class):
    some_object.some_class_method()
```

## Псевдонимы
Для полиморфизма в Python при переопределении метода в дочернем классе необходимо сохранять сигнатуру (аргументы и имена) метода базового класса. Это означает, что метод в дочернем классе должен иметь такое же имя и такой же список аргументов, как и метод в базовом классе.

Ваш метод в дочернем классе должен иметь ту же сигнатуру, чтобы Python мог понимать, что это переопределение метода. Если сигнатура будет отличаться (например, другое количество аргументов или их разные имена), то Python не будет считать это переопределением метода, и вы получите ошибку.

Таким образом, даже если вы хотите создать псевдоним для метода базового класса, сигнатура метода в дочернем классе должна оставаться той же. Вы можете внутри этого метода вызывать метод базового класса или делать что-либо другое, но сигнатура должна совпадать.

Пример:
```python
class Line(Figure):
    def draw_line(self):  # Метод с другим именем
        print(f"Drawing a line from ({self.x}, {self.y}) with color {self.color} and width {self.width}")

    # Псевдоним для метода базового класса
    def draw(self):
        self.draw_line()
```

## Инициализация объектов классов-наследников
В примере "Пполиморфизм (П)" строка вывода
```cmd
SB_001_Param_polymorph:__init__:15 - Figure __init__
```
говорит о том, что вызывается конструктор (__init__) базового класса Figure при создании экземпляра класса AsymmetricEllipse. Это происходит потому, что при создании объекта любого класса-наследника, сначала вызывается конструктор базового класса, а затем конструктор самого класса-наследника. Таким образом, Figure __init__ не относится к asym_ellipse, а относится к его базовому классу AsymmetricEllipse.

Процесс инициализации объекта наследника обычно включает в себя вызов конструктора базового класса для инициализации общих атрибутов. Это делается с помощью super().__init__(...) в конструкторе наследника. Если вы не определяете явно конструктор для класса-наследника, Python будет вызывать конструктор базового класса автоматически.

Если вам не нужно вызывать конструктор базового класса при создании экземпляра класса-наследника, вы можете определить собственный конструктор для класса-наследника и явно вызвать конструктор базового класса, если это необходимо. Например:
```python
class AsymmetricEllipse(Ellipse):
    def __init__(self, x, y, color, width):
        super().__init__(x, y, color, width)  # Явный вызов конструктора базового класса
        msg = f"Creating an asymmetric ellipse from ({x}, {y}) with color {color} and width {width}"
        logger.debug(msg)
```
Такой подход позволит вам более точно контролировать инициализацию объектов и избежать вызова конструктора базового класса, если это не требуется.

## Одноименные методы в неродственных классах
Допустим, Figure и Ellipse в не имеют родственных связей. Пусть будет создано два объекта figure и ellipse, вызовы figure.draw(), ellipse.draw() - это полиморфизм?

Полиморфизм в объектно-ориентированном программировании связан с использованием единого интерфейса (имени метода или функции) для выполнения различных действий на объектах разных классов. Код, в котором классы Figure и Ellipse имеют метод draw(), не является полиморфизмом в строгом смысле, так как вызывающий код явно указывает, какой метод вызывать для каждого объекта.

В случае, когда у вас есть два объекта figure и ellipse, вызовы figure.draw() и ellipse.draw() будут выполняться согласно реализации методов в соответствующих классах. Это означает, что для каждого объекта будет вызван соответствующий метод, но это не является полиморфизмом, так как вызывающий код явно указывает, какой метод вызывать.

Полиморфизм в более строгом смысле проявляется, когда у вас есть список объектов разных классов, и вы вызываете один и тот же метод на всех этих объектах, не зная их конкретных типов. В этом случае Python автоматически определит, какой метод вызывать на основе фактического типа объекта, что делает ваш код более гибким и универсальным.

Конкретно в данном случае вызовы figure.draw() и ellipse.draw() являются вызовами методов конкретных объектов и не являются полиморфизмом в том смысле, как обычно понимается в контексте ООП.

## Полиморфизм встроенных операторов
Зависимость поведения операторов от передаваемых параметров:
```python
def adding(x,y):
    return x + y

if __name__ == '__main__':
    x,y = 32, 41
    msg = f'adding of int x: {x} and y: {y}='+str(adding(x,y))
    logger.debug(msg)
    x,y = '32', '41'
    msg = f'adding of str x: {x} and y: {y}=' + str(adding(x, y))
    logger.debug(msg)
    x,y = [32],[41]
    msg = f'adding of lists x: {x} and y: {y}=' + str(adding(x, y))
    logger.debug(msg)
```

получим вывод
```cmd
main:<module>:8 - logging in main module started
main:<module>:31 - adding of int x: 32 and y: 41=73
main:<module>:34 - adding of str x: 32 and y: 41=3241
main:<module>:37 - adding of lists x: [32] and y: [41]=[32, 41]
```
в данном случае под капотом спрятана разная реализация оператора "+" для разных типов данных

В Python оператор + может выполнять разные действия в зависимости от типов данных операндов. Это явление называется "перегрузкой операторов" или "операторным полиморфизмом", и оно может рассматриваться как форма параметрического полиморфизма.

В данном контексте, параметрический полиморфизм связан с тем, что оператор + может работать с разными типами данных (например, числами, строками, списками) и выполнять разные операции в зависимости от типов операндов. Это делает оператор + полиморфным, так как он может принимать аргументы разных типов.

## Параметрический полиморфизм
Параметрический полиморфизм (иногда также называемый полиморфизмом по типу) включает в себя создание обобщенных функций или классов, которые могут работать с аргументами разных типов без явного указания типа. В Python параметрический полиморфизм обычно реализуется с использованием дженериков (Generics) или типовых переменных

Python - это язык с динамической типизацией, и он не обладает такой же строгой поддержкой параметрического полиморфизма, как некоторые другие языки программирования. Однако в Python вы можете использовать типовые аннотации и аннотации типовых переменных, чтобы добавить некоторую обобщенность к вашему коду.

Вот пример использования аннотаций типовых переменных для создания параметрически обобщенной функции:
```python
from typing import TypeVar, List

T = TypeVar('T')  # Определение типовой переменной T

def find_first_occurrence(item: T, items: List[T]) -> int:
    for i, element in enumerate(items):
        if element == item:
            return i
    return -1

# Использование функции с разными типами
int_list = [1, 2, 3, 4, 5]
str_list = ['apple', 'banana', 'cherry']

index1 = find_first_occurrence(3, int_list)  # Ищем число 3 в списке целых чисел
index2 = find_first_occurrence('banana', str_list)  # Ищем строку 'banana' в списке строк

print(f'Index 1: {index1}')
print(f'Index 2: {index2}')
```

