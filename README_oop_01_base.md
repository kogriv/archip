## аттрибуты
аттрибут (Attribute):

аттрибут обычно относится к членам или переменным, связанным с объектом. В Python объекты могут иметь аттрибуты, которые представляют собой данные, хранящиеся внутри объекта. аттрибуты могут быть как данными (переменными), так и методами (функциями), связанными с объектом.

Примеры использования термина "аттрибут":

аттрибуты класса: Это переменные, объявленные внутри класса, и они могут быть доступны как через объекты этого класса, так и через сам класс.
аттрибуты объекта: Это переменные, связанные с конкретным экземпляром класса

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # 'name' - аттрибут объекта
        self.age = age    # 'age' - аттрибут объекта

person1 = Person("Alice", 30)
print(person1.name)  # Обращение к аттрибуту объекта
```

## Параметры и аргументы
Параметр (Parameter):

Параметр относится к переменным, которые указываются в сигнатуре (определении) функции и используются для передачи значений в функцию при ее вызове. Параметры функции представляют собой специальные переменные, которые доступны только внутри функции и используются для обработки данных внутри нее.

Примеры использования термина "параметр":

- Формальные параметры: Это параметры, объявленные в сигнатуре функции. Они указываются в определении функции и служат для передачи аргументов функции.
- Фактические аргументы: Это значения, передаваемые при вызове функции и связанные с формальными параметрами. Фактические аргументы передаются функции, чтобы она могла использовать их в своей работе.

```python
def add(a, b):  # 'a' и 'b' - формальные параметры
    result = a + b
    return result

sum_result = add(3, 5)  # 3 и 5 - фактические аргументы
```

Параметр - это переменная, объявленная в сигнатуре (определении) функции. Параметры функции служат для принятия значений, которые будут переданы функции при ее вызове. Параметры определяются в момент создания функции и представляют собой именованные места для передачи данных в функцию.

Аргумент - это конкретное значение или выражение, которое передается функции при ее вызове. То есть, аргументы - это фактические данные или значения, которые вы передаете функции, используя параметры, объявленные в ее сигнатуре.

## Пространство имен
Имя класса попадает в пространство имен, в соответствии с уровнем, на которм объявлен данный класс. Его аттрибуты находятся в пространстве имен класса.

Сам класс образует свое пространство имен с именем своего названия.

Словарь аттрибутов класса можно получить методом `__dict__`
```python
from pprint import pprint

class Point:
    color = 'red'
    circle_radius = 3

pprint(globals(), width=60, compact=True)

# Вывести аттрибуты класса Point
pprint(Point.__dict__, width=60, compact=True)
```

Доступ к элементам пространства имен - через точку: `ClassName.class_attr`

Экземпляры класса, например `a = Point()` образуют свое пространство имен. И не содержат собственных аттрибутов:
```python
a.__dict__
```
>>>
```cmd
{}
```
Свойства (аттрибуты) color, circle берутся непосредственно из свойств порождающего класса Point.
Т.е. аттрибуты класса - общие для всех его экземпляров. Поэтому при изменении свойств на уровне класса, поменяются значения во всех объектах класса
```python
Point.circle_radius = 1
```
Получим сразу же автоматически изменение значений соотвествующих перемнных у всех объектов класса.

При явном определении значения для свойства объекта:
```python
a.circle_radius = 2
```
имя этого свойства попадет в пространство имен объекта:
```python
a.__dict__
```
output:
```cmd
{'circle_radius': 2}
```
И теперь уже при измении свойства в классе `Point.circle_radius = 1` не происходит автоматического изменения значения этого свойства в объекте "a", его свойство "защищено" локальным пространством имен.

## Создание свойств без конструктора (инициализации) `setattr`
Можно после объявления класса создавать новые свойства через точку.
```python
Point.new_prop = 'some_value'
```
Мы получим новое свойство `.new_prop` со значением 'some_value' у каждого ранее созданного объекта класса Point.

Это же можно сделать с помощью `setattr`:
```python
setattr(Point, 'property_name', 'property_value')
```

## Обращение к аттрибутам `getattr`
При обращении к несуществующему аттрибуту получим обшибку.
Используя инструкцию
```python
getattr(Point, 'not_existing_prop', 'default_value_for_not_existing_prop')
```
Можно получить значение по умолчанию 'default_value_for_not_existing_prop'

## Удаление аттрибутов `del` и `delattr`
```python
del Point.property_name
```
либо:
```python
delattr(Point, 'property_name')
```
Удаление несуществующего аттрибута выдаст ошибку.

## Проверка существования аттрибутов `hasattr`
```python
hasattr(Point, 'property_name')
```
Рузультат - булев тип.

При проверке наличия свойства у объекта - экземпляра класса, в котором (в объекте) явным образом не установлено это свойство, но оно установлено в классе:
```python
class Point:
    color = 'red'
    circle_radius = 3

a = Point()

hasattr(a, 'circle_radius')
```
мы все-равно получим `True`. Т.е. можно получить доступ к свойству `circle_radius` базового класса через пространство имен объекта `a`.

При этом удалять инструкцией `del a.circle_radius` т.е. удалять из пространства имен объекта `а` несуществующий в этом пространстве аттрибут - нельзя - получим ошибку.



