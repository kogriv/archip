# Здесь собираю информацию по архитектуре ПО. Управлению окружениями. Проектированию АПИ. ООП. Работе в ЦМД.

цмд env

Модуль venv в Python разрабатывается и поддерживается командой разработчиков Python, организованной Python Software Foundation (PSF). PSF - это некоммерческая организация, которая обеспечивает развитие и поддержку языка программирования Python и связанных с ним технологий.

Разработка модуля venv идет вместе с разработкой самого языка Python и является частью стандартной библиотеки Python. Он предоставляет удобные средства для создания виртуальных окружений Python, которые позволяют изолировать зависимости и проекты, делая управление пакетами и версиями Python более гибкими и удобными.

Организация Python Software Foundation поддерживает множество разработчиков, включая тех, кто работает над стандартной библиотекой Python, и разрабатывает модули, такие как venv, чтобы обеспечить качество и актуальность инструментов, предоставляемых Python.
-----------------------------------------------

Проверить, установлен ли venv в командной строке (cmd) Windows, выполнив следующую команду:
```
py -m venv --help
```
-m - использовать модуль

Если venv установлен, вы увидите справочную информацию о его использовании. Если вы видите сообщение об ошибке или не получаете информацию о venv, это может означать, что venv не установлен или его путь не включен в переменную среды PATH.

Если venv не установлен, вы можете установить его, выполнив следующую команду (при условии, что у вас уже установлен Python и pip):
```
py -m ensurepip --upgrade
py -m venv your_venv_name
```

C:\Users\user>py -m venv --help
usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
            [--upgrade] [--without-pip] [--prompt PROMPT]
            ENV_DIR [ENV_DIR ...]

Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR               A directory to create the environment in.

optional arguments:
  -h, --help            show this help message and exit
  --system-site-packages
                        Give the virtual environment access to the system
                        site-packages dir.
  --symlinks            Try to use symlinks rather than copies, when symlinks
                        are not the default for the platform.
  --copies              Try to use copies rather than symlinks, even when
                        symlinks are the default for the platform.
  --clear               Delete the contents of the environment directory if it
                        already exists, before environment creation.
  --upgrade             Upgrade the environment directory to use this version
                        of Python, assuming Python has been upgraded in-place.
  --without-pip         Skips installing or upgrading pip in the virtual
                        environment (pip is bootstrapped by default)
  --prompt PROMPT       Provides an alternative prompt prefix for this
                        environment.

Once an environment has been created, you may wish to activate it, e.g. by
sourcing an activate script in its bin directory.

Позиционные аргументы:

    ENV_DIR: Каталог, в котором нужно создать виртуальное окружение.

Дополнительные аргументы:

    -h, --help: Отображает эту справку и завершает выполнение программы.
    --system-site-packages: Предоставляет виртуальному окружению доступ к системным пакетам site-packages.
    --symlinks: Попытаться использовать символические ссылки вместо копирования, если символические ссылки не являются настройкой по умолчанию для данной платформы.
    --copies: Попытаться использовать копирование вместо символических ссылок, даже если символические ссылки являются настройкой по умолчанию для данной платформы.
    --clear: Удаляет содержимое каталога окружения, если он уже существует, перед созданием нового окружения.
    --upgrade: Обновить каталог окружения для использования этой версии Python, предполагая, что Python был обновлен на месте.
    --without-pip: Пропускает установку или обновление pip в виртуальном окружении (по умолчанию pip устанавливается автоматически).
    --prompt PROMPT: Предоставляет альтернативный префикс приглашения для этого окружения.

    Команда venv используется для создания виртуальных окружений Python, и ENV_DIR представляет собой путь к каталогу, в котором будет создано виртуальное окружение. Вот несколько примеров использования ENV_DIR:

Создание виртуального окружения в текущем каталоге с именем "myenv":
    venv myenv

Создание виртуального окружения в другом каталоге, например, "C:\Projects\myproject", с именем "myenv":
    venv C:\Projects\myproject\myenv

Создание виртуальных окружений в нескольких каталогах сразу:
    venv env1 env2 env3
    В этом случае будут созданы виртуальные окружения с именами "env1", "env2" и "env3" в текущем рабочем каталоге.

Создание виртуального окружения в каталоге с пробелами в имени (путь обязан быть заключен в кавычки):
    venv "C:\Projects\My Project\myenv"

Создание виртуального окружения с использованием относительного пути:
    venv ../myenv

Если не срабатывает
    venv myenv

Проблема заключается в том, что команда venv не распознается в вашей командной строке. Это может произойти, если venv не включен в переменную среды PATH, либо если в вашей системе используется другая версия Python, в которой venv может иметь другое имя.

В этом случае, вы можете попробовать использовать python -m venv для создания виртуального окружения. Вот как это сделать:
    Откройте командную строку (cmd) в Windows.
    Перейдите в каталог, где вы хотите создать виртуальное окружение.
    Затем выполните следующую команду, указав полный путь к интерпретатору Python:

    python -m venv myenv
    
Где python - это полный путь к исполняемому файлу Python. В вашем случае, возможно, это python3, python3.9, или что-то подобное в зависимости от вашей версии Python.
Если команда успешно выполнится, она создаст виртуальное окружение с именем "arch" в текущем каталоге.

Для активации созданного виртуального окружения (venv) в командной строке Windows, вы должны выполнить скрипт активации, который находится в каталоге Scripts вашего виртуального окружения. Вот как это сделать:

    Откройте командную строку (cmd) в Windows.

    Перейдите в каталог, где находится ваше виртуальное окружение. Например, если вы создали виртуальное окружение с именем "myenv" в текущем каталоге, перейдите в него следующей командой:
    cd path\to\myenv

    Для командной строки (cmd):
    Scripts\activate

    Для PowerShell:
    Scripts\Activate.ps1


Аргумент --system-site-packages используется при создании виртуального окружения (venv) для предоставления виртуальному окружению доступа к системным библиотекам Python, которые находятся в директории site-packages системного Python. Это может быть полезно, если вы хотите использовать некоторые библиотеки, установленные глобально на вашей системе, внутри вашего виртуального окружения. Вот несколько примеров команд с использованием аргумента --system-site-packages:

Создание виртуального окружения с доступом к системным библиотекам:
    python -m venv --system-site-packages myenv

Создание нескольких виртуальных окружений с доступом к системным библиотекам:
    python -m venv --system-site-packages env1 env2 env3

Создание виртуального окружения без доступа к системным библиотекам (по умолчанию):
    python -m venv myenv

При использовании --system-site-packages, виртуальное окружение будет иметь доступ к библиотекам, установленным в системном Python. Это может быть полезно, когда вам нужно использовать библиотеки, которые уже установлены на вашем компьютере, и вы не хотите их дублировать в виртуальном окружении.

Аргумент --symlinks используется при создании виртуального окружения (venv) для указания, что следует попытаться использовать символические ссылки вместо копирования библиотек Python, когда символические ссылки не являются настройкой по умолчанию для вашей операционной системы. Использование символических ссылок может сэкономить дисковое пространство и уменьшить время создания виртуального окружения. Вот несколько примеров команд с использованием аргумента --symlinks:

Создание виртуального окружения с использованием символических ссылок (если они доступны на вашей ОС):
    python -m venv --symlinks myenv

Создание нескольких виртуальных окружений с использованием символических ссылок:
    python -m venv --symlinks env1 env2 env3

Создание виртуального окружения с копированием библиотек (если символические ссылки - настройка по умолчанию):
    python -m venv myenv

При использовании --symlinks, виртуальное окружение будет пытаться использовать символические ссылки для библиотек Python, если это поддерживается вашей операционной системой. Если символические ссылки не поддерживаются, будет использоваться копирование. Это может быть полезно для экономии дискового пространства и ускорения создания виртуальных окружений, если символические ссылки поддерживаются на вашей системе.

Аргумент --copies используется при создании виртуального окружения (venv) для указания, что следует попытаться использовать копирование библиотек Python вместо символических ссылок, даже если символические ссылки являются настройкой по умолчанию для вашей операционной системы. Использование копий может быть полезным в ситуациях, когда символические ссылки не подходят или не поддерживаются на вашей системе. Вот несколько примеров команд с использованием аргумента --copies:

Создание виртуального окружения с использованием копий библиотек:
    python -m venv --copies myenv

Создание нескольких виртуальных окружений с использованием копий:
    python -m venv --copies env1 env2 env3

Создание виртуального окружения с использованием символических ссылок (если они доступны на вашей ОС):
    python -m venv myenv

При использовании --copies, виртуальное окружение будет пытаться использовать копирование библиотек Python, даже если символические ссылки являются настройкой по умолчанию для вашей операционной системы. Это может быть полезно, если символические ссылки не поддерживаются или вызывают проблемы на вашей системе.

Аргумент --upgrade используется при создании виртуального окружения (venv) для обновления окружения до использования текущей версии Python, предполагая, что Python был обновлен на месте. Вот пример команды с использованием аргумента --upgrade:

Обновление виртуального окружения до текущей версии Python:
    python -m venv --upgrade myenv

Эта команда используется, когда вы хотите убедиться, что ваше виртуальное окружение использует текущую версию Python, которая может быть установлена после создания окружения. В результате выполнения этой команды, виртуальное окружение будет обновлено, чтобы использовать текущую версию Python, доступную на вашей системе.

В контексте аргумента --upgrade при создании виртуального окружения (venv), "текущей версией" обычно понимается версия Python, установленная на хост-машине, на которой вы выполняете команду создания виртуального окружения.

Это означает, что --upgrade обновляет виртуальное окружение, чтобы использовать версию Python, которая установлена на вашей системе на момент выполнения команды. Например, если на вашей системе установлена Python 3.9, и вы создали виртуальное окружение с Python 3.7, выполнение --upgrade обновит виртуальное окружение до Python 3.9.

Аргумент --upgrade не связан с версиями Python, доступными в интернете или глобально. Это всегда обновление виртуального окружения на основе версии, установленной на вашем компьютере.

---------------------------------
можно ли установить ВО внутри ВО?

Да, в большинстве случаев можно создать виртуальное окружение (ВО) внутри другого виртуального окружения. Этот процесс называется "вложенными виртуальными окружениями". Это может быть полезно в сценариях разработки, когда вам нужно создать изолированное окружение для проекта, который сам использует виртуальное окружение для управления своими зависимостями.

Вот как создать вложенное виртуальное окружение:

    Активируйте внешнее виртуальное окружение, в котором вы хотите создать вложенное ВО.

    После активации внешнего ВО, выполните команду для создания вложенного ВО, как обычно. Например:
    python -m venv my_nested_env

    Это создаст вложенное ВО с именем my_nested_env внутри текущего внешнего ВО.
Выход из внешнего ВО не влияет на вложенное ВО. Вложенное ВО остается активным внутри внешнего. Вы можете активировать вложенное ВО так же, как и внешнее ВО, и управлять зависимостями в нем.

Для выхода из вложенного ВО и возврата во внешнее ВО, используйте команду deactivate. После этого вы снова будете внутри внешнего ВО.
Важно отметить, что вложенные виртуальные окружения создают дополнительный уровень изоляции для управления зависимостями, но это также может создать некоторую сложность в управлении окружениями. Убедитесь, что это действительно необходимо в вашем конкретном случае.

Вложенные виртуальные окружения (ВО) решают ряд типичных задач, связанных с разработкой и управлением зависимостями в проектах Python:
    Изоляция зависимостей проекта: Когда у вас есть проект, который требует конкретных версий библиотек или зависимостей, вложенные ВО позволяют вам создать изолированное окружение, где будут установлены только необходимые библиотеки для этого проекта. Это предотвращает конфликты между зависимостями разных проектов.

    Тестирование и разработка с разными версиями Python: Вы можете создавать вложенные ВО для тестирования своего проекта с разными версиями Python. Например, вы можете иметь внешнее ВО с Python 3.7 и вложенное ВО с Python 3.8 для проверки совместимости вашего кода с разными версиями интерпретатора.

    Создание виртуального окружения внутри виртуального окружения: Иногда вам может понадобиться внутри проекта создать ещё одно изолированное окружение. Это может быть полезно, когда вы разрабатываете веб-приложение, использующее фреймворк Django, и вы хотите создать отдельное ВО для управления зависимостями вашего фронтенда, например, React.

    Разработка и тестирование библиотек: Если вы разрабатываете библиотеку, вложенные ВО могут быть полезными для тестирования этой библиотеки в разных окружениях Python без влияния на другие проекты.

    Обновление окружения к последней версии Python: Вложенные ВО могут быть использованы для обновления окружения до последней версии Python. Вы можете создать вложенное ВО с новой версией Python и проверить, как ваши проекты работают с ней, прежде чем обновить внешние окружения.

    Изоляция системных библиотек и Python: Если вы работаете в среде, где системные библиотеки и Python могут быть изменены, вложенные ВО могут обеспечить стабильное и изолированное окружение для ваших проектов.

    Работа с разными версиями фреймворков и платформ: Вложенные ВО могут быть полезными для разработки и тестирования на разных версиях фреймворков и платформ, таких как Django, Flask, или разные версии операционных систем.

В целом, вложенные ВО предоставляют мощное средство управления зависимостями и окружениями Python, что делает их полезными инструментами для разработчиков при работе над различными проектами и сценариями.

Количество уровней вложенности виртуальных окружений Python (ВО) теоретически не ограничено. Вы можете создавать вложенные ВО внутри других вложенных ВО, и так далее. Однако важно понимать, что каждое вложенное ВО создает дополнительный уровень изоляции и увеличивает сложность управления окружениями.

При использовании большого числа вложенных ВО стоит учитывать следующие аспекты:

    Сложность управления: Чем больше уровней вложенности, тем сложнее становится управление окружениями. Вам может потребоваться активировать и деактивировать каждое окружение вручную.

    Использование ресурсов: Каждое ВО потребляет ресурсы, такие как дисковое пространство для установленных пакетов и оперативную память при выполнении кода. Слишком много вложенных ВО может привести к избыточному использованию ресурсов.

    Уровни изоляции: Большее количество уровней изоляции может быть полезным для предотвращения конфликтов зависимостей, но оно также может сделать разработку и тестирование более сложными и затратными.

    Зависимости и настройки: При увеличении уровней вложенности важно следить за зависимостями и настройками в каждом ВО. Это может потребовать дополнительных усилий для поддержания согласованных и стабильных окружений.

Исходя из этих соображений, рекомендуется использовать вложенные ВО с умеренностью и основывать решение на конкретных потребностях проекта. В большинстве случаев одно вложенное ВО может быть достаточным для управления зависимостями и изоляцией проекта от других проектов и системных библиотек.

--------------------------------

Аргумент --without-pip используется при создании виртуального окружения (venv) для пропуска установки или обновления инструмента управления пакетами Python (pip) внутри виртуального окружения. Это может быть полезным, если вы хотите создать минимальное окружение без pip или если вы хотите использовать другой инструмент для управления пакетами. Вот несколько примеров команд с использованием аргумента --without-pip:

Создание виртуального окружения без pip:
    python -m venv --without-pip myenv

Создание нескольких виртуальных окружений без pip:
    python -m venv --without-pip env1 env2 env3

Создание виртуального окружения с установкой pip (по умолчанию, без использования аргумента --without-pip):
    python -m venv myenv

Когда вы создаете виртуальное окружение с помощью --without-pip, pip не будет установлен внутри этого окружения, и вы не сможете использовать pip для установки пакетов внутри этого окружения, пока pip не будет установлен вручную.

Чтобы установить pip внутри виртуального окружения без pip, вы можете использовать скрипт get-pip.py (который можно скачать с сайта pip). Например:
```
# Активируйте виртуальное окружение
source myenv/bin/activate

# Скачайте скрипт установки pip
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py

# Запустите скрипт установки pip внутри виртуального окружения
python get-pip.py
```
После выполнения этих команд pip будет установлен внутри вашего виртуального окружения, и вы сможете использовать его для управления пакетами в этом окружении.

Аргумент --prompt PROMPT используется при создании виртуального окружения (venv) для установки пользовательской строки приглашения (prompt), которая будет отображаться в командной строке при активации данного виртуального окружения. Это может быть полезным для идентификации и различения разных виртуальных окружений. Вот примеры команд с использованием аргумента --prompt:

Создание виртуального окружения с пользовательским приглашением:
    python -m venv --prompt myenvprompt myenv

В этом примере, myenvprompt - это пользовательское приглашение (prompt), которое будет отображаться при активации виртуального окружения myenv.

    Создание виртуального окружения с другим пользовательским приглашением:
    python -m venv --prompt devenv dev

В этом случае, devenv - это пользовательское приглашение (prompt) для виртуального окружения dev.

Когда вы активируете виртуальное окружение с пользовательским приглашением, в командной строке вы увидите это приглашение, чтобы помочь вам определить текущее активное окружение. Например:

    (devenv) C:\path\to\myenv>

    Пользовательские приглашения могут быть полезными, особенно если у вас есть множество виртуальных окружений и вы хотите легко идентифицировать, в каком окружении вы работаете.

Настройка пользовательской строки приглашения (--prompt) в виртуальном окружении (ВО) полезна в нескольких типичных случаях:

    Идентификация окружения: Если у вас есть несколько виртуальных окружений и вы хотите быстро идентифицировать, в каком окружении вы работаете в данный момент, настройка пользовательской строки приглашения может помочь. Вы можете включить в строку приглашения имя окружения или другую информацию, которая помогает вам понять, где вы находитесь.

    Разные проекты: Если у вас есть несколько проектов, каждый из которых требует своих зависимостей, вы можете создать виртуальное окружение для каждого проекта и настроить строку приглашения для каждого ВО, чтобы было понятно, с каким проектом вы работаете.

    Отличие от глобального окружения: Строка приглашения может также помочь вам ясно видеть, что вы работаете в виртуальном окружении, а не в глобальном окружении Python, установленном на вашей системе.

    Определение конфигурации окружения: Вы можете включить в строку приглашения информацию о конфигурации вашего окружения, такую как версия Python, версия важных библиотек и т.д. Это может быть полезно для быстрой проверки текущей конфигурации.

    Удобство: Для многих разработчиков настройка строки приглашения просто делает работу более удобной. Это позволяет быстро распознавать текущее окружение и избегать путаницы.

В итоге, настройка строки приглашения - это инструмент для улучшения удобства работы с виртуальными окружениями и помощь в избегании ошибок при работе с разными окружениями и проектами.

-------------------------------------

Когда вы активируете виртуальное окружение (ВО) в командной строке (или терминале), это активирует ВО только в текущем окне командной строки или терминала. Активация ВО не распространяется на другие окна командной строки или терминалы, которые вы можете открыть параллельно.

Каждое окно командной строки (или терминал) работает в своем собственном процессе и имеет свое собственное окружение. Активация ВО в одном окне не повлияет на другие окна.

Это полезно, так как позволяет вам иметь разные ВО для разных проектов или задач, и вы можете активировать их по мере необходимости в соответствующих окнах командной строки или терминала.

Каждое окно командной строки (или терминал) работает в своем собственном процессе, что означает, что оно выполняется в отдельной программе в операционной системе. Это важное понятие в контексте того, как виртуальные окружения (ВО) и команды, связанные с ВО, взаимодействуют с окружением операционной системы.

Вот некоторые ключевые моменты, связанные с этим понятием:

    Разные окна - разные процессы: Каждое окно командной строки, которое вы открываете, запускается в своем собственном процессе операционной системы. Это означает, что изменения и настройки, сделанные в одном окне, не затрагивают другие окна.

    Изоляция ВО: Виртуальные окружения (ВО) предназначены для изоляции зависимостей и пакетов между проектами. Когда вы активируете ВО в одном окне командной строки, это ВО становится активным только в этом окне. Другие окна не будут знать о существовании или активации этого ВО.

    Системные и глобальные переменные: Каждое окно командной строки имеет свои собственные переменные окружения, включая переменные Python, PATH, и другие. Изменения переменных в одном окне не отразятся на переменных в других окнах.

    Изоляция процессов: Каждый процесс, запущенный в одном окне, изолирован от процессов в других окнах. Это означает, что если вы выполняете программу или сервер в одном окне, он не будет виден из других окон.

Важно понимать это, потому что при работе с ВО вам может потребоваться активировать ВО в каждом окне командной строки (или терминала), где вы планируете выполнять свой код или управлять зависимостями. Каждое окно имеет свою собственную среду выполнения, и активация ВО в одном окне не затронет другие окна.

-------------------------

Системные и глобальные переменные, такие как PATH и другие, могут оказать влияние на способ работы вашей системы и программ, включая Python. Вот как их можно просмотреть и управлять ими:

PATH (переменная PATH):

    Windows: Переменная PATH определяет список директорий, в которых операционная система ищет исполняемые файлы, включая интерпретатор Python. Вы можете просмотреть текущее значение PATH в командной строке Windows с помощью команды:
    echo %PATH%

    Powershell:
    echo $Env:PATH

    macOS и Linux: Вы можете просмотреть текущее значение PATH в терминале macOS или Linux с помощью команды:
    echo $PATH

Переменные Python:

    Python также имеет свои собственные переменные окружения, которые могут влиять на его поведение. Вы можете просмотреть некоторые из них, используя команду python -m site, которая покажет информацию о местоположении конфигурации Python и другие параметры, такие как sys.prefix и sys.executable.

    Вот пример:
    python -m site

Установленные пакеты Python:

    Для просмотра списка установленных пакетов и их версий в виртуальном окружении или глобально, вы можете использовать команду pip list или pip freeze. Например:
    pip list

    Или для вывода в формате, удобном для сохранения в файл:
    pip freeze > requirements.txt
        Где requirements.txt - это файл, содержащий список установленных пакетов и их версий.

Чтобы изменить переменные окружения или управлять зависимостями, вы можете внести изменения в соответствующие файлы конфигурации или использовать специфические команды, такие как export (для Linux и macOS) или set (для Windows), чтобы временно изменить переменные в текущей сессии командной строки.

существуют различные терминалы и интерфейсы командной строки (CLI), которые предоставляют дополнительные возможности для управления процессами и переменными окружения на Windows и Linux. Вот некоторые из них:

Для Linux:

    tmux: Это мультиплексор терминала, который позволяет вам создавать и управлять несколькими терминальными сессиями и окнами одновременно. Вы можете использовать его для создания разных окон для отслеживания процессов и изменения переменных окружения.

    screen: Аналогично tmux, screen - это терминальный мультиплексор, который позволяет создавать отдельные терминальные сессии.

    htop: Это интерактивная утилита для мониторинга процессов в реальном времени. Htop предоставляет более продвинутые возможности отслеживания процессов по сравнению с командой top.

Для Windows:

    PowerShell: PowerShell - это мощный командный интерфейс для управления Windows и его компонентами. Он предоставляет богатые возможности для работы с процессами, файлами и переменными окружения.

    Cmder: Это популярный терминал для Windows, который предоставляет улучшенные возможности командной строки и позволяет удобно управлять процессами и переменными окружения.

    Windows Subsystem for Linux (WSL): Если у вас установлен WSL, вы можете использовать терминал внутри Linux-среды для выполнения команд Linux, включая управление процессами и переменными окружения.

    Process Explorer: Это бесплатная утилита от Microsoft, которая предоставляет подробную информацию о запущенных процессах в Windows. Вы можете использовать ее для отслеживания и завершения процессов.

Чтобы управлять системными и глобальными переменными, вы можете использовать команды для установки, изменения и удаления переменных в вашей системе. В Linux это часто делается с помощью команды export, а в Windows - с помощью команд setx или через панель управления. Подробности могут зависеть от вашей операционной системы и версии.

Важно заметить, что использование продвинутых терминалов и инструментов требует определенных знаний, поэтому ознакомьтесь с документацией и учебными материалами для каждого инструмента, чтобы использовать их эффективно.

-----------------
Задание явного имени ВО полезно, когда у вас есть несколько проектов и вы хотите легко идентифицировать, к какому проекту принадлежит каждое ВО. Это помогает избежать путаницы и конфликтов между разными окружениями.

Общепринятым и часто используемым именем для виртуального окружения (ВО) является "venv". Это имя просто указывает на то, что вы создаете стандартное виртуальное окружение для Python. Многие разработчики и инструкции по созданию ВО используют именно это имя.

    python -m venv venv

Использование имени .venv для виртуального окружения (ВО) является распространенной практикой, и оно имеет свои преимущества. Вот почему разработчики иногда предпочитают использовать это имя:

    Скрытое имя: В Linux и macOS файлы и каталоги, начинающиеся с точки (например, .venv), считаются скрытыми и обычно не отображаются в обозревателях файлов по умолчанию. Это может быть полезно, чтобы не загромождать список файлов в директории проекта ВО.

    Исключение из системы контроля версий: Если вы используете систему контроля версий, такую как Git, то имя .venv по умолчанию будет проигнорировано (игнорироваться в .gitignore), что предотвращает добавление виртуального окружения в репозиторий, что часто желательно.

    Ясность и единообразие: Использование .venv в качестве имени ВО может сделать ваши проекты более ясными и удобными для других разработчиков. Это распространенное соглашение и может улучшить читаемость вашего кода.

    python -m venv .venv
-------------------


После установки окружения, необходимо обновить менеджер пакетов pip
Проверка версии
pip -V
апгрэйд
pip install -U pip

-----------------------

модули пакеты

Функции с нижним подчеркиванием не передаются в область видимости принимающего модуля при импорте

Wildcard импорт
from module_name import *

импортируется область глоб имен модуля. за исключением _function_name

При запуске пи.файла в котором есть импорт модуля
import module

в корневой папке создастся папка __pycache__
в которую попадает скомпилированный модуль modul в бинарнике(?)

В .gitignore добавить
__pycache__/

---------------------
Использовать везде:

def main():
    ...

    if __name__ == '__main__':
    nain()

в main() упаковывается сценарий работы модуля при его непосредственном запуске
__name__ может иметь значения либо __main__ , либо имя_модуля (при импорте)

------------------

аттрибуты
результат вывода ф-и
dir(module)

список с аттрибутами модуля.
Интересующие вас значения, обычно, будут атрибутами и функциями, которые вы хотите использовать в своем коде, и вы сможете обращаться к ним, используя точечную нотацию, например, module.some_attribute или module.some_function().

__builtins__, __cached__ и другие атрибуты, которые вы видите в списке, это встроенные атрибуты модуля в Python. Они предоставляют информацию о модуле и его окружении. Например:

    __builtins__: Этот атрибут ссылается на встроенный модуль Python, который содержит встроенные функции и объекты, такие как print(), len(), str(), и много других. Вы можете получить доступ к этим функциям и объектам, используя __builtins__.имя.

    __cached__: Этот атрибут хранит путь к кэшированной (скомпилированной) версии модуля, если такая версия доступна. Он используется для ускорения повторных импортов модуля. Вы можете получить доступ к этому пути, чтобы узнать, где хранится скомпилированный модуль.

Для получения значений этих атрибутов, вы можете использовать обычную точечную нотацию:
    ```
    import module
    builtins_module = module.__builtins__
    cached_path = module.__cached__
    ...
    ```
 Обычно __builtins__ не рекомендуется модифицировать, так как это может привести к непредсказуемому поведению интерпретатора Python. Этот атрибут лучше всего использовать только для чтения встроенных функций и объектов.

 __builtins__ - это словарь, который содержит встроенные функции, объекты и классы Python. Этот словарь предоставляет доступ ко всем стандартным функциям и объектам, которые доступны в Python без явного импорта. Внутри этого словаря находятся встроенные функции, такие как print(), len(), str(), а также встроенные исключения, такие как TypeError, ValueError, NameError и многие другие. Также в нем находятся базовые типы данных, такие как int, float, str, и так далее.

Например, если вы хотите использовать функцию len() или объект int, вы можете обращаться к ним через __builtins__ так:
    ```
    length = __builtins__.len([1, 2, 3])
    number = __builtins__.int("42")
    ```
В этом словаре также содержится информация о версии Python и различные системные настройки.

Таким образом, __builtins__ предоставляет доступ к стандартным инструментам и объектам Python, и они могут быть использованы без необходимости импорта.

-----------------

просто dir() вернет глобальное пространство имен модуля в котором вызывается

-----------------

доступно из коробки:
    ```
    import builtins
    print(dir(builtins))
    ```
---------------------


пакеты

пакет - способ организации модулей в одну структуру

Импортирование модулей пакета через точку
    ```
    import package.module
    ```

Файлы __init__.py в пакетах Python играют важную роль в организации кода и делают каталог, содержащий эти файлы, интерпретатору Python понятным как пакет. Вот как они используются и для чего:

    Определение Пакета: Когда вы создаете каталог и добавляете в него файл __init__.py, Python интерпретирует этот каталог как пакет. Это означает, что вы можете организовывать свой код в логические группы с использованием пакетов. Пакеты могут содержать другие модули (файлы .py) и даже другие подпакеты.

    Выполнение Инициализации: Файл __init__.py выполняется при импорте пакета. Это позволяет вам выполнять инициализацию кода, устанавливать переменные, создавать объекты или выполнять любые другие действия, которые необходимы для корректной работы вашего пакета.

    Экспорт Объектов: Вы можете определить переменные, функции, классы или другие объекты в файле __init__.py, чтобы они были доступны извне пакета при импорте. Это позволяет вам управлять тем, какие объекты будут видны пользователю при импорте вашего пакета.

Пример:

Предположим, у вас есть следующая структура пакета:
    ```
    my_package/
        __init__.py
        module1.py
        module2.py
    ```

В файле __init__.py вы можете определить, какие объекты будут доступны при импорте my_package:
    ```
    # my_package/__init__.py

    # Этот объект будет доступен при импорте my_package
    package_variable = "Hello from my_package"

    # Вы также можете импортировать объекты из других модулей внутри пакета
    from .module1 import my_function
    ```
Теперь, при импорте my_package, переменная package_variable и функция my_function будут доступны извне пакета:
    ```
    import my_package

    print(my_package.package_variable)  # Вывод: Hello from my_package
    my_package.my_function()  # Вызов функции из module1.py
    ```
Файлы __init__.py также могут быть пустыми, если вам не нужно выполнять какие-либо специфические действия при импорте пакета, но их наличие всё равно обязательно, чтобы Python интерпретировал каталог как пакет.

Для того чтобы при импорте пакета можно было использовать только module1.py и не импортировать module2.py, вы можете использовать атрибут __all__ в файле __init__.py. Этот атрибут определяет список модулей и объектов, которые будут импортированы, если пакет импортируется с использованием from package import *. Ваш файл __init__.py может выглядеть следующим образом:
    ```
    # my_package/__init__.py

    __all__ = ['module1']
    ```

Теперь, при импорте пакета с использованием from my_package import *, будут доступны только объекты и модули, указанные в списке __all__ (в данном случае, только module1).
    ```
    from my_package import *

    print(package_variable)  # Вывод: Hello from my_package
    my_function()  # Вызов функции из module1.py

    # module2 не будет доступен, так как его нет в списке __all__
    # module2.some_function()  # Это вызовет ошибку NameError
    ```
Этот способ ограничивает экспорт только теми модулями и объектами, которые указаны в __all__ и предостерегает от неожиданных импортов из пакета.

В Python, в файле __init__.py пакета, вы не можете прямо ограничить импорт определенных переменных и функций из модулей внутри пакета. Все имена, которые определены в модуле и не начинаются с символа подчеркивания (например, _private_name), по умолчанию будут доступны при импорте из пакета. Это следует из принципов языка Python, которые способствуют удобству и читаемости кода.

Однако, вы можете использовать соглашения и договоренности в вашем коде, чтобы обозначить, какие имена считать "публичными" и какие "приватными". Обычно в Python считается, что имена, начинающиеся с символа подчеркивания (например, _private_name), являются "приватными" и не предназначены для использования извне модуля. Это соглашение основано на конвенции и зависит от дисциплины программистов, но интерпретатор Python не накладывает жестких ограничений на доступ к именам.

 Атрибут __all__ в файле __init__.py пакета применяется только к ограничению импорта определенных модулей из пакета, но не к ограничению импорта переменных и функций внутри этих модулей.

Атрибут __all__ определяет список модулей, которые будут импортированы, если вы используете оператор from package import *, и не влияет на доступность переменных и функций внутри этих модулей.

Чтобы ограничить доступ к переменным и функциям внутри модуля, вы можете использовать соглашения о именах, такие как добавление символа подчеркивания _ в начало имени (например, _private_variable), чтобы указать, что эти переменные или функции предназначены только для внутреннего использования и не рекомендуется к импорту извне модуля.

Для точного ограничения доступа к переменным и функциям внутри модулей, Python не предоставляет средств на уровне пакета, и рекомендуется полагаться на соглашения и документирование кода, чтобы явно указать, какие объекты считаются "приватными" и не предназначены для импорта извне.

---------------------------

Локальный импорт в __init__.py
    ```
    from .module import function
    ```
    Далее при импорте пакета получаем прямой доступ к локально импортированным объектам
    ```
    import package
    package.function()
    ```
Это нужно, чтобы в больших программах максимально прозрачно защищать пространство имен