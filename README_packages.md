модули пакеты

Функции с нижним подчеркиванием не передаются в область видимости принимающего модуля при импорте

Wildcard импорт
```python
from module_name import *
```

импортируется область глоб имен модуля. за исключением _function_name

При запуске пи.файла в котором есть импорт модуля
import module

в корневой папке создастся папка __pycache__
в которую попадает скомпилированный модуль module в бинарнике(?)

В .gitignore добавить
__pycache__/

---------------------
Использовать везде:
```python
def main():
    ...

    if __name__ == '__main__':
    nain()
```

в main() упаковывается сценарий работы модуля при его непосредственном запуске
__name__ может иметь значения либо __main__ , либо имя_модуля (при импорте)

------------------

аттрибуты
результат вывода ф-и
```python
dir(module)
```

список с аттрибутами модуля.
Интересующие вас значения, обычно, будут атрибутами и функциями, которые вы хотите использовать в своем коде, и вы сможете обращаться к ним, используя точечную нотацию, например, module.some_attribute или module.some_function().

__builtins__, __cached__ и другие атрибуты, которые вы видите в списке, это встроенные атрибуты модуля в Python. Они предоставляют информацию о модуле и его окружении. Например:

&nbsp;&nbsp;&nbsp;&nbsp;__builtins__: Этот атрибут ссылается на встроенный модуль Python, который содержит встроенные функции и объекты, такие как print(), len(), str(), и много других. Вы можете получить доступ к этим функциям и объектам, используя __builtins__.имя.

&nbsp;&nbsp;&nbsp;&nbsp;__cached__: Этот атрибут хранит путь к кэшированной (скомпилированной) версии модуля, если такая версия доступна. Он используется для ускорения повторных импортов модуля. Вы можете получить доступ к этому пути, чтобы узнать, где хранится скомпилированный модуль.

Для получения значений этих атрибутов, вы можете использовать обычную точечную нотацию:
```python
import module
builtins_module = module.__builtins__
cached_path = module.__cached__
...
```
 Обычно __builtins__ не рекомендуется модифицировать, так как это может привести к непредсказуемому поведению интерпретатора Python. Этот атрибут лучше всего использовать только для чтения встроенных функций и объектов.

 __builtins__ - это словарь, который содержит встроенные функции, объекты и классы Python. Этот словарь предоставляет доступ ко всем стандартным функциям и объектам, которые доступны в Python без явного импорта. Внутри этого словаря находятся встроенные функции, такие как print(), len(), str(), а также встроенные исключения, такие как TypeError, ValueError, NameError и многие другие. Также в нем находятся базовые типы данных, такие как int, float, str, и так далее.

Например, если вы хотите использовать функцию len() или объект int, вы можете обращаться к ним через __builtins__ так:
```python
length = __builtins__.len([1, 2, 3])
number = __builtins__.int("42")
```
В этом словаре также содержится информация о версии Python и различные системные настройки.

Таким образом, __builtins__ предоставляет доступ к стандартным инструментам и объектам Python, и они могут быть использованы без необходимости импорта.

-----------------

просто dir() вернет глобальное пространство имен модуля в котором вызывается

-----------------

доступно из коробки:
```python
import builtins
print(dir(builtins))
```
---------------------


пакеты

пакет - способ организации модулей в одну структуру

Импортирование модулей пакета через точку
```python
import package.module
```

Файлы __init__.py в пакетах Python играют важную роль в организации кода и делают каталог, содержащий эти файлы, интерпретатору Python понятным как пакет. Вот как они используются и для чего:

    Определение Пакета: Когда вы создаете каталог и добавляете в него файл __init__.py, Python интерпретирует этот каталог как пакет. Это означает, что вы можете организовывать свой код в логические группы с использованием пакетов. Пакеты могут содержать другие модули (файлы .py) и даже другие подпакеты.

    Выполнение Инициализации: Файл __init__.py выполняется при импорте пакета. Это позволяет вам выполнять инициализацию кода, устанавливать переменные, создавать объекты или выполнять любые другие действия, которые необходимы для корректной работы вашего пакета.

    Экспорт Объектов: Вы можете определить переменные, функции, классы или другие объекты в файле __init__.py, чтобы они были доступны извне пакета при импорте. Это позволяет вам управлять тем, какие объекты будут видны пользователю при импорте вашего пакета.

Пример:

Предположим, у вас есть следующая структура пакета:
```powershell
my_package/
    __init__.py
    module1.py
    module2.py
```

В файле __init__.py вы можете определить, какие объекты будут доступны при импорте my_package:
```python
# my_package/__init__.py

# Этот объект будет доступен при импорте my_package
package_variable = "Hello from my_package"

# Вы также можете импортировать объекты из других модулей внутри пакета
from .module1 import my_function
```
Теперь, при импорте my_package, переменная package_variable и функция my_function будут доступны извне пакета:
```python
import my_package

print(my_package.package_variable)  # Вывод: Hello from my_package
my_package.my_function()  # Вызов функции из module1.py
```
Файлы __init__.py также могут быть пустыми, если вам не нужно выполнять какие-либо специфические действия при импорте пакета, но их наличие всё равно обязательно, чтобы Python интерпретировал каталог как пакет.

Для того чтобы при импорте пакета можно было использовать только module1.py и не импортировать module2.py, вы можете использовать атрибут __all__ в файле __init__.py. Этот атрибут определяет список модулей и объектов, которые будут импортированы, если пакет импортируется с использованием from package import *. Ваш файл __init__.py может выглядеть следующим образом:
```python
# my_package/__init__.py

__all__ = ['module1']
```

Теперь, при импорте пакета с использованием from my_package import *, будут доступны только объекты и модули, указанные в списке __all__ (в данном случае, только module1).
```python
from my_package import *

print(package_variable)  # Вывод: Hello from my_package
my_function()  # Вызов функции из module1.py

# module2 не будет доступен, так как его нет в списке __all__
# module2.some_function()  # Это вызовет ошибку NameError
```
Этот способ ограничивает экспорт только теми модулями и объектами, которые указаны в __all__ и предостерегает от неожиданных импортов из пакета.

В Python, в файле __init__.py пакета, вы не можете прямо ограничить импорт определенных переменных и функций из модулей внутри пакета. Все имена, которые определены в модуле и не начинаются с символа подчеркивания (например, _private_name), по умолчанию будут доступны при импорте из пакета. Это следует из принципов языка Python, которые способствуют удобству и читаемости кода.

Однако, вы можете использовать соглашения и договоренности в вашем коде, чтобы обозначить, какие имена считать "публичными" и какие "приватными". Обычно в Python считается, что имена, начинающиеся с символа подчеркивания (например, _private_name), являются "приватными" и не предназначены для использования извне модуля. Это соглашение основано на конвенции и зависит от дисциплины программистов, но интерпретатор Python не накладывает жестких ограничений на доступ к именам.

 Атрибут __all__ в файле __init__.py пакета применяется только к ограничению импорта определенных модулей из пакета, но не к ограничению импорта переменных и функций внутри этих модулей.

Атрибут __all__ определяет список модулей, которые будут импортированы, если вы используете оператор from package import *, и не влияет на доступность переменных и функций внутри этих модулей.

Чтобы ограничить доступ к переменным и функциям внутри модуля, вы можете использовать соглашения о именах, такие как добавление символа подчеркивания _ в начало имени (например, _private_variable), чтобы указать, что эти переменные или функции предназначены только для внутреннего использования и не рекомендуется к импорту извне модуля.

Для точного ограничения доступа к переменным и функциям внутри модулей, Python не предоставляет средств на уровне пакета, и рекомендуется полагаться на соглашения и документирование кода, чтобы явно указать, какие объекты считаются "приватными" и не предназначены для импорта извне.

---------------------------

Локальный импорт в __init__.py
```python
from .module import function
```
    Далее при импорте пакета получаем прямой доступ к локально импортированным объектам
```python
import package
package.function()
```
Это нужно, чтобы в больших программах максимально прозрачно защищать пространство имен