## Скрытые модули пакеты
Функции с нижним подчеркиванием `_` не передаются в область видимости принимающего модуля при импорте.

**Wildcard** импорт:
```python
from module_name import *
```

импортируется область глоб имен модуля. за исключением _function_name.

## \_\_pycache\_\_
При запуске пи.файла, в котором есть импорт модуля  
import module,

в корневой папке создастся папка **\_\_pycache\_\_**
в которую попадает скомпилированный модуль module в бинарнике(?)

В .gitignore добавить
\_\_pycache\_\_/

## if \_\_name\_\_ == '\_\_main\_\_':
Использовать везде:
```python
def main():
    ...

    if __name__ == '__main__':
    nain()
```

в main() упаковывается сценарий работы модуля при его непосредственном запуске
`__name__` может иметь значения либо `__main__` , либо имя_модуля (при импорте)

## Аттрибуты (`__builtins__` словарь переменных области видимости)
Результат вывода функции:
```python
dir(module)
```

список с аттрибутами модуля.
Интересующие вас значения, обычно, будут атрибутами и функциями, которые вы хотите использовать в своем коде, и вы сможете обращаться к ним, используя точечную нотацию, например, `module.some_attribute` или `module.some_function().`

`__builtins__`, `__cached__` и другие атрибуты, которые вы видите в списке, это встроенные атрибуты модуля в Python. Они предоставляют информацию о модуле и его окружении. Например:

&nbsp;&nbsp;&nbsp;&nbsp;`__builtins__`: Этот атрибут ссылается на встроенный модуль Python, который содержит встроенные функции и объекты, такие как `print()`, `len()`, `str()`, и много других. Вы можете получить доступ к этим функциям и объектам, используя `__builtins__.имя`.

&nbsp;&nbsp;&nbsp;&nbsp;`__cached__`: Этот атрибут хранит путь к кэшированной (скомпилированной) версии модуля, если такая версия доступна. Он используется для ускорения повторных импортов модуля. Вы можете получить доступ к этому пути, чтобы узнать, где хранится скомпилированный модуль.

Для получения значений этих атрибутов, вы можете использовать обычную точечную нотацию:
```python
import module
builtins_module = module.__builtins__
cached_path = module.__cached__
...
```
 Обычно `__builtins__` не рекомендуется модифицировать, так как это может привести к непредсказуемому поведению интерпретатора Python. Этот атрибут лучше всего использовать только для чтения встроенных функций и объектов.

 `__builtins__` - это словарь, который содержит встроенные функции, объекты и классы Python. Этот словарь предоставляет доступ ко всем стандартным функциям и объектам, которые доступны в Python без явного импорта. Внутри этого словаря находятся встроенные функции, такие как `print()`, `len()`, `str()`, а также встроенные исключения, такие как `TypeError`, `ValueError`, `NameError` и многие другие. Также в нем находятся базовые типы данных, такие как `int`, `float`, `str`, и так далее.

Например, если вы хотите использовать функцию `len()` или объект `int`, вы можете обращаться к ним через `__builtins__` так:
```python
length = __builtins__.len([1, 2, 3])
number = __builtins__.int("42")
```
В этом словаре также содержится информация о версии Python и различные системные настройки.

Таким образом, `__builtins__` предоставляет доступ к стандартным инструментам и объектам Python, и они могут быть использованы без необходимости импорта.

## Просто dir()
Просто dir() вернет глобальное пространство имен модуля в котором вызывается

Доступно из коробки:
```python
import builtins
print(dir(builtins))
```

# Пакеты
Пакет - способ организации модулей в одну структуру.

Импортирование модулей пакета через точку.
```python
import package.module
```

## Файлы `__init__.py`
Файлы `__init__.py` в пакетах Python играют важную роль в организации кода и делают каталог, содержащий эти файлы, интерпретатору Python понятным как пакет. Вот как они используются и для чего:

- **Определение Пакета**: Когда вы создаете каталог и добавляете в него файл `__init__.py`, Python интерпретирует этот каталог как пакет. Это означает, что вы можете организовывать свой код в логические группы с использованием пакетов. Пакеты могут содержать другие модули (файлы `.py`) и даже другие подпакеты.

- **Выполнение инициализации**: Файл `__init__.py` выполняется при импорте пакета. Это позволяет вам выполнять инициализацию кода, устанавливать переменные, создавать объекты или выполнять любые другие действия, которые необходимы для корректной работы вашего пакета.

- **Экспорт Объектов**: Вы можете определить переменные, функции, классы или другие объекты в файле `__init__.py`, чтобы они были доступны извне пакета при импорте. Это позволяет вам управлять тем, какие объекты будут видны пользователю при импорте вашего пакета.

Файлы `__init__.py` могут быть пустыми, если вам не нужно выполнять какие-либо специфические действия при импорте пакета, но ***их наличие всё равно обязательно, чтобы Python интерпретировал каталог как пакет***.

## Прямой доступ к нужным частям пакета извне
Предположим, у вас есть следующая структура пакета:
```powershell
my_package/
    __init__.py
    module1.py
    module2.py
```
В файле `__init__.py` вы можете определить, какие объекты будут доступны при импорте my_package:
```python
# my_package/__init__.py
# Этот объект будет доступен при импорте my_package
package_variable = "Hello from my_package"
# Вы также можете импортировать объекты из других модулей внутри пакета
from .module1 import my_function
```
Теперь, при импорте `my_package`, переменная `package_variable` и функция `my_function` будут доступны извне пакета:
```python
import my_package

print(my_package.package_variable)  # Вывод: Hello from my_package
my_package.my_function()  # Вызов функции из module1.py
```
## атрибут `__all__`
Для того чтобы при импорте пакета можно было использовать только `module1.py` и не импортировать `module2.py`, вы можете использовать атрибут `__all__` в файле `__init__.py`. Этот атрибут определяет список модулей и объектов, которые будут импортированы, если пакет импортируется с использованием `from package import *`. Ваш файл `__init__.py` может выглядеть следующим образом:
```python
# my_package/__init__.py

__all__ = ['module1']
```

Теперь, при импорте пакета с использованием `from my_package import *`, будут доступны только объекты и модули, указанные в списке `__all__` (в данном случае, только `module1`).
```python
from my_package import *

print(package_variable)  # Вывод: Hello from my_package
my_function()  # Вызов функции из module1.py

# module2 не будет доступен, так как его нет в списке __all__
# module2.some_function()  # Это вызовет ошибку NameError
```
Этот способ ограничивает экспорт только теми модулями и объектами, которые указаны в `__all__` и предостерегает от неожиданных импортов из пакета.

## Ограничения импорта.
В Python, в файле `__init__.py` пакета, вы не можете прямо ограничить импорт определенных переменных и функций из модулей внутри пакета. Все имена, которые определены в модуле и не начинаются с символа подчеркивания (например, `_private_name`), по умолчанию будут доступны при импорте из пакета. Это следует из принципов языка Python, которые способствуют удобству и читаемости кода.

Однако, вы можете использовать **соглашения и договоренности** в вашем коде, чтобы обозначить, какие имена считать "публичными" и какие "приватными". Обычно в Python считается, что имена, начинающиеся с символа подчеркивания (например, `_private_name`), являются **"приватными"** и не предназначены для использования извне модуля. Это соглашение основано на конвенции и зависит от дисциплины программистов, но интерпретатор Python не накладывает жестких ограничений на доступ к именам.

Атрибут `__all__` в файле `__init__.py` пакета применяется только к ограничению импорта определенных модулей из пакета, но не к ограничению импорта переменных и функций внутри этих модулей.

Атрибут `__all__` определяет список модулей, которые будут импортированы, если вы используете оператор `from package import *`, и не влияет на доступность переменных и функций внутри этих модулей.

Для точного ограничения доступа к переменным и функциям внутри модулей, Python не предоставляет средств на уровне пакета, и рекомендуется полагаться на соглашения и документирование кода, чтобы явно указать, какие объекты считаются "приватными" и не предназначены для импорта извне.

## Локальный импорт
Локальный импорт в __init__.py
```python
from .module import function
```
Далее при импорте пакета получаем прямой доступ к локально импортированным объектам
```python
import package
package.function()
```
Это нужно, чтобы в больших программах максимально прозрачно защищать пространство имен

## "Дублирующий импорт"
Когда вы импортируете библиотеку, например `LightGBM` (LGBM), в одном модуле (назовем его `mod1`), а затем импортируете этот модуль (`mod1`) в другой модуль (`mod2`) и также импортируете `LightGBM` непосредственно в `mod2`, это не приводит к значительному увеличению затрат ресурсов вашего компьютера. Вот почему:
- Механизм **кэширования импорта** в Python: Когда модуль импортируется в Python, он кэшируется (запоминается системой). Если модуль уже импортирован где-то в программе, повторные попытки импорта будут ссылаться на уже импортированный модуль, а не загружать его заново. Таким образом, даже если вы импортируете LGBM в mod1 и затем снова в mod2, фактический процесс импорта (загрузка и инициализация) происходит только один раз.
- **Поддержка модульности**: Данная структура поддерживает модульность кода. Это значит, что каждый модуль может импортировать необходимые ему библиотеки, даже если они уже импортированы где-то еще. Это улучшает читаемость и поддерживаемость кода.
- Незначительное **увеличение времени загрузки**: Единственный небольшой недостаток может заключаться в незначительном увеличении времени запуска программы, поскольку интерпретатору Python необходимо проверить, был ли модуль уже импортирован. Однако это обычно не оказывает заметного влияния на производительность.
- **Память**: В отношении использования памяти, поскольку модуль загружается только один раз, не происходит дополнительного расхода памяти из-за такого «двойного» импорта.

